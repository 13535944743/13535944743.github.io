<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赤蓝紫</title>
  
  <subtitle>赤蓝紫</subtitle>
  <link href="https://www.clzczh.top/atom.xml" rel="self"/>
  
  <link href="https://www.clzczh.top/"/>
  <updated>2022-05-18T14:06:57.354Z</updated>
  <id>https://www.clzczh.top/</id>
  
  <author>
    <name>赤蓝紫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代理与反射(二)</title>
    <link href="https://www.clzczh.top/2022/05/18/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84-%E4%BA%8C/"/>
    <id>https://www.clzczh.top/2022/05/18/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84-%E4%BA%8C/</id>
    <published>2022-05-18T14:06:24.000Z</published>
    <updated>2022-05-18T14:06:57.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理与反射-二"><a href="#代理与反射-二" class="headerlink" title="代理与反射(二)"></a>代理与反射(二)</h1><p>使用代理模式可以实现一些有用的功能。</p><h2 id="捕获操作"><a href="#捕获操作" class="headerlink" title="捕获操作"></a>捕获操作</h2><p>通过添加对应捕获器，就可以捕获<code>get</code>、<code>set</code>、<code>has</code>等操作，可以监控这个对象何时在何处被访问过，并且能在访问、修改前干想干的事，并通过反射重新实现原功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;<br><br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, property, receiver</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`访问 <span class="hljs-subst">$&#123;property&#125;</span>`</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(...arguments)<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, property, value, receiver</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`设置 <span class="hljs-subst">$&#123;property&#125;</span>=<span class="hljs-subst">$&#123;value&#125;</span>`</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(...arguments)<br>  &#125;<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(proxy.name)<br>proxy.age = <span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/903534137d674199b87b12dfd352c715~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220503205936504"></p><p>这里有一个需要小小注意的点：通过代理对象的操作才会被捕获，而直接操作目标对象的操作不会被捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;<br><br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, property, receiver</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`访问 <span class="hljs-subst">$&#123;property&#125;</span>`</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(...arguments)<br>  &#125;<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(proxy.name)<br><span class="hljs-built_in">console</span>.log(user.name)<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f06bf52e9be34cb198b1859e2bf05c7e~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220503205922840"></p><h2 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h2><p>因为代理的内部实现对于外部的代码来说是不可见的，所以想要隐藏目标对象上的属性也很容易实现。我们上面说过，需要通过反射来实现原功能，但是我们也可以不实现原功能，而是返回其他值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">21</span><br>&#125;;<br><br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, property, receiver</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (property === <span class="hljs-string">&#x27;name&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 隐藏name属性</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(...arguments)<br>  &#125;<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(user)<br><span class="hljs-built_in">console</span>.log(user.name)<br><span class="hljs-built_in">console</span>.log(user.age)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;%c%s&#x27;</span>, <span class="hljs-string">&#x27;font-size:24px;color:red&#x27;</span>, <span class="hljs-string">&#x27;=================&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(proxy)<br><span class="hljs-built_in">console</span>.log(proxy.name)<br><span class="hljs-built_in">console</span>.log(proxy.age)<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1eef69a7616b453f94668b4c4e798d16~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220503210140040"></p><p>从上图，我们可以知道，直接访问目标对象、目标对象属性以及访问代理对象都能能到一样的结果。但是，通过代理访问<code> name</code>属性会得到<code> undefined</code>，因为我们在捕获操作中进行了隐藏属性。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h3><p>因为所有的赋值操作都会触发<code>set</code>捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值，不通过验证，直接<code>return false</code>即可拒绝赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">21</span><br>&#125;;<br><br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, &#123;<br>  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, property, value</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;不是number类型，拒绝赋值&#x27;</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(...arguments);<br>    &#125;<br>  &#125;<br>&#125;);<br><br>proxy.age = <span class="hljs-number">999</span>;<br><span class="hljs-built_in">console</span>.log(proxy.age);<br><br>proxy.age = <span class="hljs-string">&#x27;111&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(proxy.age);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/clzczh/picgo/raw/master/images/202205182206283.png" alt="image-20220503211445808"></p><p>当我们返回<code> false</code>时，即不通过验证，就可以不进行原始行为的实现，</p><h3 id="函数参数验证"><a href="#函数参数验证" class="headerlink" title="函数参数验证"></a>函数参数验证</h3><p>和验证对象属性类似，也可以对函数的参数进行审查。</p><p>首先，函数也是能使用代理的。<code>apply</code>捕获器会在调用函数时被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123; &#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(fn, &#123;<br>    <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;调用函数&#x27;</span>)<br>    &#125;<br>&#125;);<br><br>proxy(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><br></code></pre></td></tr></table></figure><p>所以我们应该在<code> apply</code>捕获器中进行操作验证。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mysort</span>(<span class="hljs-params">...nums</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>&#125;<br><br><br><span class="hljs-comment">// 在`apply`捕获器中进行参数验证</span><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(mysort, &#123;<br>  <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">target, thisArg, argumentsList</span>)</span> &#123;<br>    <span class="hljs-comment">// target: 目标对象</span><br>    <span class="hljs-comment">// thisArg: 调用函数时的this参数</span><br>    <span class="hljs-comment">// argumentsList: 调用函数时的参数列表</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arg <span class="hljs-keyword">of</span> argumentsList) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arg !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;函数参数必须为number&#x27;</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.apply(...arguments);<br>  &#125;<br>&#125;);<br><br><span class="hljs-keyword">let</span> fin = proxy(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.log(fin);<br><br>fin = proxy(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.log(fin);<br></code></pre></td></tr></table></figure><p>构造函数同理，只是构造函数是通过<code>constructor</code>捕获器来实现代理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(Person, &#123;<br>  <span class="hljs-function"><span class="hljs-title">construct</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.construct(...arguments)<br>  &#125;<br>&#125;);<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> proxy(<span class="hljs-string">&#x27;clz&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(p)<br></code></pre></td></tr></table></figure><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>通过代理可以把原本运行中不相关的部分联系到一起。</p><p>例子：将被代理的类绑定到一个全局的实例集合，将所有创建的实例都添加到这个集合中。`</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userList = []<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name_ = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(User, &#123;<br>    <span class="hljs-function"><span class="hljs-title">construct</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> newUser = <span class="hljs-built_in">Reflect</span>.construct(...arguments)<br>        userList.push(newUser)<br>        <span class="hljs-keyword">return</span> newUser<br>    &#125;<br>&#125;)<br><br><br><span class="hljs-keyword">new</span> proxy(<span class="hljs-string">&#x27;clz&#x27;</span>)<br><span class="hljs-keyword">new</span> proxy(<span class="hljs-string">&#x27;czh&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(userList)<br></code></pre></td></tr></table></figure><h2 id="事件分发程序"><a href="#事件分发程序" class="headerlink" title="事件分发程序"></a>事件分发程序</h2><p>在开始之前，先来一个小问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nums = []<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(nums, &#123;<br>  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, property, value, receiver</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setting&#x27;</span>)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(...arguments)<br>  &#125;<br>&#125;)<br><br>proxy.push(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>上面的代码会打印两次<code>setting</code>。</p><p>这是为什么呢？</p><p>让我们把它每一轮修改的属性打印出来，研究一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nums = []<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(nums, &#123;<br>  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, property, value, receiver</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setting&#x27;</span>)<br><br>    <span class="hljs-built_in">console</span>.log(property)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(...arguments)<br>  &#125;<br>&#125;)<br><br>proxy.push(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6c6732dd96f40759967520e9cd51270~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220503234749114"></p><p>我们可以发现，第一次是0，第二次是<code> length</code>。也就是说，push实际上是分成两个阶段的，第一轮先修改数组，第二轮再修改数组长度，所以会打印两轮。(没有找到权威的解释，实践测试得出的结论，有问题可评论)</p><p>回到正题：可以把集合绑定给一个事件分发程序，实现每次插入新实例时，都会发送消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nums = []<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">emit</span>(<span class="hljs-params">newValue</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;有新数据，新数据是&#x27;</span>, newValue)<br>&#125;<br><br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(nums, &#123;<br>  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, property, value, receiver</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">Reflect</span>.set(...arguments)<br>    <span class="hljs-comment">// Reflect.set返回boolean值，该值指示该属性是否已成功设置</span><br><br>    <span class="hljs-keyword">if</span> (result) &#123;<br>      <span class="hljs-comment">// 如果被成功设置了，调用事件分派函数，把新插入的值作为参数传过去</span><br><br>      emit(<span class="hljs-built_in">Reflect</span>.get(target, property, receiver))<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>&#125;)<br><br>proxy.push(<span class="hljs-number">111</span>)<br>proxy.push(<span class="hljs-number">222</span>)<br><span class="hljs-built_in">console</span>.log(proxy)<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74f89d3919374532a574f7f53c2932cb~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220503235521715"></p><p>这里可以发现，我们<code> push</code>两条数据，但是会触发事件分发程序4次，这是为什么？</p><p>这就是这一小节上面讲的，<strong>push实际上是分成两个阶段的，第一轮先修改数组，第二轮再修改数组长度</strong>。</p><p>所以，我们不应该只是判断是否被成功设置，还应该判断属性是不是<code> length</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (result &amp;&amp; property !== <span class="hljs-string">&#x27;length&#x27;</span>) &#123;<br>  <span class="hljs-comment">// 如果被成功设置了，调用事件分派函数，把新插入的值作为参数传过去</span><br><br>  emit(<span class="hljs-built_in">Reflect</span>.get(target, property, receiver))<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/clzczh/picgo/raw/master/images/202205182206579.png" alt="image-20220504000010868"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;代理与反射-二&quot;&gt;&lt;a href=&quot;#代理与反射-二&quot; class=&quot;headerlink&quot; title=&quot;代理与反射(二)&quot;&gt;&lt;/a&gt;代理与反射(二)&lt;/h1&gt;&lt;p&gt;使用代理模式可以实现一些有用的功能。&lt;/p&gt;
&lt;h2 id=&quot;捕获操作&quot;&gt;&lt;a href=&quot;#捕</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>代理与反射(一)</title>
    <link href="https://www.clzczh.top/2022/05/18/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84-%E4%B8%80/"/>
    <id>https://www.clzczh.top/2022/05/18/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84-%E4%B8%80/</id>
    <published>2022-05-18T14:05:28.000Z</published>
    <updated>2022-05-18T14:05:49.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理与反射-一"><a href="#代理与反射-一" class="headerlink" title="代理与反射(一)"></a>代理与反射(一)</h1><p>ES6新增的代理与反射提供了拦截，并且能够增加其他行为。实际上，就有点像ES6之前的<code> Object.defineProperty</code>。用法就是，通过<code> Proxy</code>构造函数给目标对象定义一个关联的代理对象，还可以添加捕获器，之后这个代理对象就能够作为抽象的目标对象来使用，而在操作影响到目标对象之前，会被定义的捕获器劫持。</p><h2 id="代理的简单使用"><a href="#代理的简单使用" class="headerlink" title="代理的简单使用"></a>代理的简单使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;get&#x27;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)<br><br><span class="hljs-built_in">console</span>.log(target.name)    <span class="hljs-comment">// clz</span><br><span class="hljs-built_in">console</span>.log(proxy.name)     <span class="hljs-comment">// get(因为被劫持了)</span><br><br>proxy.name = <span class="hljs-string">&#x27;czh&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(target.name)    <span class="hljs-comment">// czh</span><br><span class="hljs-built_in">console</span>.log(proxy.name)     <span class="hljs-comment">// get</span><br></code></pre></td></tr></table></figure><p>所有捕获器都可以访问到相应的参数，基于这些参数可以重新执行被捕获方法的原始行为。<code>get()</code>捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">trapTarget, property, receiver</span>)</span> &#123;<br><br>    <span class="hljs-built_in">console</span>.log(trapTarget === target)  <span class="hljs-comment">// true</span><br>    <span class="hljs-built_in">console</span>.log(property)               <span class="hljs-comment">// name</span><br>    <span class="hljs-built_in">console</span>.log(receiver === proxy)     <span class="hljs-comment">// true</span><br><br>    <span class="hljs-keyword">return</span> trapTarget[property]<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)<br><br><br><span class="hljs-built_in">console</span>.log(target.name)    <span class="hljs-comment">// clz</span><br><span class="hljs-built_in">console</span>.log(proxy.name)     <span class="hljs-comment">// clz</span><br></code></pre></td></tr></table></figure><h2 id="反射的简单使用"><a href="#反射的简单使用" class="headerlink" title="反射的简单使用"></a>反射的简单使用</h2><p>从上面的例子中，我们已经知道可以通过捕获器的参数重建原始行为，但是重建原始行为比较麻烦，特别是不同的捕获器重建的方法不同。这时候就是我们的<code> Reflect</code>对象的的闪亮登场了，它封装了原始行为，所以我们只需要调用同名方法就能轻松重建原始行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(...arguments)<br>  &#125;<br><br>  <span class="hljs-comment">// 更简洁版本</span><br>  <span class="hljs-comment">// get: Reflect.get</span><br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)<br><br><br><span class="hljs-built_in">console</span>.log(target.name)    <span class="hljs-comment">// clz</span><br><span class="hljs-built_in">console</span>.log(proxy.name)     <span class="hljs-comment">// clz</span><br></code></pre></td></tr></table></figure><h2 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h2><p>捕获器不变式就是指会防止捕获器定义出现不合理的行为。</p><p>比如：如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123;&#125;<br><br><span class="hljs-built_in">Object</span>.defineProperty(target, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// return &#x27;clz&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;czh&#x27;</span>  <span class="hljs-comment">// 如果属性为不可写，但是返回了与该属性不同的值的话，就会报错</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)<br><br><span class="hljs-built_in">console</span>.log(proxy.name)<br></code></pre></td></tr></table></figure><h2 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h2><p>代理是可以撤销的。通过调用<code>Proxy.revocable()</code>方法，这个方法返回的对象中，有代理对象<code> proxy</code>，以及撤销代理的方法<code> revoke</code>。撤销代理的操作是不可逆的。撤销代理之后再调用代理会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello&#x27;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> &#123; proxy, revoke &#125; = <span class="hljs-built_in">Proxy</span>.revocable(target, handler)<br><br><span class="hljs-built_in">console</span>.log(proxy.name)<br><span class="hljs-built_in">console</span>.log(target.name)<br><br>revoke()<br><br><span class="hljs-built_in">console</span>.log(proxy.name)  <span class="hljs-comment">// TypeError: Cannot perform &#x27;get&#x27; on a proxy that has been revoked</span><br></code></pre></td></tr></table></figure><h2 id="代理另一个代理"><a href="#代理另一个代理" class="headerlink" title="代理另一个代理"></a>代理另一个代理</h2><p>我们的代理不一定只是能代理普通的对象，还能够代理另一个代理，做法和代理普通的对象一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;<br><br><br><span class="hljs-keyword">const</span> firstProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第一次代理&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(...arguments)<br>  &#125;<br>&#125;)<br><br><span class="hljs-keyword">const</span> secondProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(firstProxy, &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第二次代理&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(...arguments)<br>  &#125;<br>&#125;)<br><br><br><span class="hljs-built_in">console</span>.log(secondProxy.name)<br></code></pre></td></tr></table></figure><p>通过代理去影响目标对象会按最后的代理一次回到最初的代理的顺序。</p><p><img src="https://gitee.com/clzczh/picgo/raw/master/images/202205182205594.png" alt="image-20220503184006055"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;代理与反射-一&quot;&gt;&lt;a href=&quot;#代理与反射-一&quot; class=&quot;headerlink&quot; title=&quot;代理与反射(一)&quot;&gt;&lt;/a&gt;代理与反射(一)&lt;/h1&gt;&lt;p&gt;ES6新增的代理与反射提供了拦截，并且能够增加其他行为。实际上，就有点像ES6之前的&lt;code&gt;</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端下载文件的几种方式</title>
    <link href="https://www.clzczh.top/2022/05/18/%E5%89%8D%E7%AB%AF%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://www.clzczh.top/2022/05/18/%E5%89%8D%E7%AB%AF%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2022-05-18T14:03:43.000Z</published>
    <updated>2022-05-18T14:04:25.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端下载文件的几种方式"><a href="#前端下载文件的几种方式" class="headerlink" title="前端下载文件的几种方式"></a>前端下载文件的几种方式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实习一个人负责一个管理系统的前端部分。其中，就有前端下载文件的需要。最终采用的是使用<code>axios</code>发送<code>get</code>请求的方式，因为需要携带<code>token</code>。但是，不应该只注重结果，也应该注重过程，不然可能一直都是拧螺丝。另外提一嘴，找工作最好还是找能去的最大的公司，虽然小公司也能学到东西，但是因为制度不完善的缘故，可能会被不好的小公司坑，问就是一行泪。(去的小公司开始对实习生下手了，甚至有请假回去答辩时被背刺的)</p><h2 id="a链接"><a href="#a链接" class="headerlink" title="a链接"></a>a链接</h2><h3 id="极简版本"><a href="#极简版本" class="headerlink" title="极简版本"></a>极简版本</h3><p>实际上，如果a链接的<code>href</code>就是指向文件的地址的话，是可以直接下载的。这种方式下载的文件名就是原本的文件名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;a href=&quot;https://www.clzczh.top/medias/test.xlsx&quot;&gt;下载文件&lt;/a&gt;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/clzczh/picgo/raw/master/images/202205182204001.png" alt="image-20220430181604786"></p><h3 id="自定义文件名"><a href="#自定义文件名" class="headerlink" title="自定义文件名"></a>自定义文件名</h3><p>通过<code>download</code>属性，可以实现对下载的文件进行重命名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;a href=&quot;https://www.clzczh.top/medias/test.xlsx&quot; download=&quot;clz.xlsx&quot;&gt;下载文件&lt;/a&gt;<br></code></pre></td></tr></table></figure><p>上面不能实现重命名？</p><p>这是因为通过<code>download</code>属性来实现对下载的文件进行重命名需要是同源路径下。</p><p>换成同源路径后，就能实现自定义文件名了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;a href=&quot;/test.xlsx&quot; download=&quot;clz.xlsx&quot;&gt;下载文件&lt;/a&gt;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08b09718607f473a85c49c3e7a606d84~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220430183758385"></p><h3 id="动态添加a标签"><a href="#动态添加a标签" class="headerlink" title="动态添加a标签"></a>动态添加a标签</h3><p>在上面的例子中，我们是通过点击a标签来实现下载文件的。但是，实际上，我们也可以通过动态添加a标签的形式来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;button onclick=&quot;download()&quot;&gt;下载文件&lt;/button&gt;<br><br>&lt;script&gt;<br>  function download() &#123;<br>    const a = document.createElement(&#x27;a&#x27;)<br>    a.href = &#x27;/test.xlsx&#x27;<br>    a.download = &#x27;clz.xlsx&#x27;<br>    a.click()<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>结果和上面一样</p><h2 id="指定location的href"><a href="#指定location的href" class="headerlink" title="指定location的href"></a>指定location的href</h2><p>通过指定<code>location</code>对象的<code>href</code>属性，就可以在当前页面打开URL页面，其实就和上面a链接的极简版本一样效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;button onclick=&quot;download()&quot;&gt;下载文件&lt;/button&gt;<br><br>&lt;script&gt;<br>  function download() &#123;<br>    window.location.href = &#x27;/test.xlsx&#x27;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>无法重命名</p><h2 id="window-open"><a href="#window-open" class="headerlink" title="window.open"></a>window.open</h2><p>打开指定的页面的URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;button onclick=&quot;download()&quot;&gt;下载文件&lt;/button&gt;<br><br>&lt;script&gt;<br>  function download() &#123;<br>    window.open(&#x27;/test.xlsx&#x27;)<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>无法重命名</p><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>因为下载文件其实就相当于发起get请求，所以可以使用axios来发起请求，这样子就能够很方便地携带token等信息。</p><p><strong>因为是下载文件，所以响应类型应该是<code>blob</code>，用来存取二进制数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;button onclick=&quot;download()&quot;&gt;下载文件&lt;/button&gt;<br><br>&lt;script&gt;<br>  function download() &#123;<br>    axios(&#123;<br>      url: &quot;/test.xlsx&quot;,<br>      method: &#x27;GET&#x27;,<br>      responseType: &#x27;blob&#x27;,     // 用来存取二进制数据<br>      headers: &#123;<br>        token: &#x27;testtest&#x27;     // 可以携带token<br>      &#125;<br>    &#125;).then(res =&gt; &#123;<br>      console.log(res)<br>    &#125;)<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffee4314982444be8a90e7c85559142b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220430212722930"></p><p>不过，此时并没有下载文件，因为此时是二进制数据。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d27712ef57bf494d9b94982224900b2f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220430212915220"></p><p>所以，我们还需要将二进制数据变成文件下载。</p><p>那么，怎么将二进制数据变成文件呢？</p><p>这里在网上找到一个方法，就是通过<code>URL.createObjectURL</code>方法，生成对应二进制数据<code>blob</code>对象的URL，然后通过动态添加a标签的方法，来实现生成文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;button onclick=&quot;download()&quot;&gt;下载文件&lt;/button&gt;<br><br>&lt;script&gt;<br>  function download() &#123;<br>    axios(&#123;<br>      url: &quot;/test.xlsx&quot;,<br>      method: &#x27;GET&#x27;,<br>      responseType: &#x27;blob&#x27;,<br>      headers: &#123;<br>        token: &#x27;testtest&#x27;     // 可以携带token<br>      &#125;<br>    &#125;).then(res =&gt; &#123;<br><br><br>      const href = URL.createObjectURL(res.data)<br>      // console.log(href)<br><br>      const a = document.createElement(&#x27;a&#x27;)<br>      a.download = &#x27;clz.xlsx&#x27;<br>      a.href = href<br><br>      a.click()<br>    &#125;)<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>将二进制数据变成文件也可以通过<code>FileReader</code>的<code>readAsDataURL</code>来实现，该方法读取<code>blob</code>对象或<code>file</code>对象。读取成功后，能够通过<code>onload</code>回调函数中通过实例对象的<code>target</code>属性下的<code>result</code>属性中获取base64编码的URL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">const reader = new FileReader()<br><br>reader.readAsDataURL(res.data)<br><br>reader.onload = (e) =&gt; &#123;<br>  console.log(e)<br><br>  const a = document.createElement(&#x27;a&#x27;)<br>  a.download = &#x27;clz.xlsx&#x27;<br>  a.href = e.target.result<br><br>  a.click()<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/600f6ba520c44ab3b314b8c00f855d07~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220430215628865"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端下载文件的几种方式&quot;&gt;&lt;a href=&quot;#前端下载文件的几种方式&quot; class=&quot;headerlink&quot; title=&quot;前端下载文件的几种方式&quot;&gt;&lt;/a&gt;前端下载文件的几种方式&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS隐藏元素的几种方式</title>
    <link href="https://www.clzczh.top/2022/04/30/css-%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0/"/>
    <id>https://www.clzczh.top/2022/04/30/css-%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0/</id>
    <published>2022-04-30T09:25:22.000Z</published>
    <updated>2022-04-30T09:25:42.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS隐藏元素的几种方式"><a href="#CSS隐藏元素的几种方式" class="headerlink" title="CSS隐藏元素的几种方式"></a>CSS隐藏元素的几种方式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开始之前，先来了解一下回流和重绘的概念。(经小伙伴评论提醒，后来加的内容)</p><p>回流：当我们修改元素的几何位置属性，如宽度、高度时，浏览器会重新布局，这个过程就叫回流</p><p>重绘：当我们修改元素的绘制属性，如背景色、颜色等，浏览器不会重新布局，但是需要重新进入绘制阶段，这个过程就是重绘。</p><p>可以通过<strong>css triggers</strong>网站查询元素是否会导致回流、重绘。</p><p><strong>回流一定会触发重绘，重绘不一定会触发回流</strong></p><h2 id="display-none"><a href="#display-none" class="headerlink" title="display: none"></a>display: none</h2><p>最常见的隐藏元素的方法，不会渲染该元素，所以该元素不会占位置，也不会响应绑定的事件。</p><p>html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;div&gt;&lt;/div&gt;<br>&lt;div onclick=&quot;alert(&#x27;赤蓝紫&#x27;)&quot;&gt;&lt;/div&gt;<br>&lt;div&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>css</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">body &#123;<br>    display: flex;<br>&#125;<br><br>div &#123;<br>    width: 100px;<br>    height: 100px;<br>&#125;<br><br>div:nth-child(1) &#123;<br>    background-color: red;<br>&#125;<br><br>div:nth-child(2) &#123;<br>    display: none;<br>    background-color: blue;<br>&#125;<br><br>div:nth-child(3) &#123;<br>    background-color: purple;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/clzczh/picgo/raw/master/images/202204301725236.png" alt="image-20220427230639837"></p><p>那么<code>display</code>会不会引发回流、重绘呢？</p><p>答案是必然的，当我们修改<code>display</code>时，它会突然地出现或消失(即会修改元素的位置)，所以会引发回流，引发回流自然就会引发重绘。但是，如果一开始就是<code>none</code>，那么倒是不会多次触发回流，因为不会渲染该元素。</p><h2 id="visibility-hidden"><a href="#visibility-hidden" class="headerlink" title="visibility: hidden"></a>visibility: hidden</h2><p>元素在页面中会保留位置，但是不会响应绑定的事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">div:nth-child(2) &#123;<br>    visibility: hidden;<br>    background-color: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60b9392120b7410b8fd4c39a9f2e53be~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220427230927696"></p><p>元素会在页面中保留位置，并没有几何位置属性的变化，所以并不会触发回流，会重绘。</p><h2 id="opacity-0"><a href="#opacity-0" class="headerlink" title="opacity: 0"></a>opacity: 0</h2><p>将元素的透明度设置为0。所以元素在页面中会保留位置，且也<strong>能响应元素绑定的监听事件</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">div:nth-child(2) &#123;<br>    opacity: 0;<br>    background-color: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b0729ec8cb147a992af72de2583a6dc~tplv-k3u1fbpfcp-zoom-1.image" alt="css"></p><p>元素会在页面中保留位置，并没有几何位置属性的变化，所以并不会触发回流，会重绘。</p><h2 id="定位法"><a href="#定位法" class="headerlink" title="定位法"></a>定位法</h2><h3 id="绝对定位法"><a href="#绝对定位法" class="headerlink" title="绝对定位法"></a>绝对定位法</h3><p>因为绝对定位可以让元素脱离标准流，所以只需要设置绝对定位，就可以让元素移出可视范围内，这样子就相当于隐藏了。又因为是移出可以范围，所以监听事件无效；元素脱离了标准流，所以不会保留位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">div:nth-child(2) &#123;<br>    position: absolute;<br>    top: -200px;<br>    background-color: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb7c2123696845e3b72d87d79a6b442a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220428212006431"></p><p>绝对定位会会让元素的位置发生变化，所以会触发回流，但是让元素绝对定位后，再进行其他会导致回流的操作，就能减少回流代价。</p><h3 id="相对定位法"><a href="#相对定位法" class="headerlink" title="相对定位法"></a>相对定位法</h3><p>相对定位法和绝对定位法类似，都是让元素移出可是范围内。不同的是，相对定位不会脱离标准流，所以会保留位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">div:nth-child(2) &#123;<br>    position: relative;<br>    top: -200px;<br>    background-color: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d945a13a16a44bddb11ac6d21bd64688~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220428213632477"></p><p>与绝对定位同理，也会触发回流</p><h2 id="缩放法"><a href="#缩放法" class="headerlink" title="缩放法"></a>缩放法</h2><p>通过<code>scale</code>将元素缩放为0，元素保留位置，监听事件无效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">div:nth-child(2) &#123;<br>    transform: scale(0, 0);<br>    background-color: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d8f56f4021f49c4810ac162c4003f60~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220428213940493"></p><p><code>transform</code>属性不会触发回流、重绘。</p><p>简单地说下为什么<code>transform</code>属性为什么不会触发回流、重绘。</p><p>CSS的最终表现可以分为4步：计算样式 -&gt; 排布 -&gt; 绘制 -&gt; 组合层(<strong>Recalculate Style</strong> -&gt; <strong>Layout</strong> -&gt; <strong>Paint Setup and Paint</strong> -&gt; <strong>Composite Layers</strong>)</p><p>而<code>transform</code>是位于最后的组合层，所以不会触发回流重绘。而且一些浏览器也会针对<code>transform</code>开启GPU加速。</p><p>顺便提一嘴：只是查询属性也会强制发生回流。比如<code>width</code>位置<code>Layout</code>层，所以只是通过js访问它也会导致回流。</p><h2 id="降低层次法"><a href="#降低层次法" class="headerlink" title="降低层次法"></a>降低层次法</h2><p>通过<code>z-index</code>来降低当前元素的层次，让其他元素遮盖该元素来实现隐藏。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">div:nth-child(2) &#123;<br>    position: absolute;<br>    z-index: -999;<br>    background-color: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/clzczh/picgo/raw/master/images/202204301725701.png" alt="image-20220428214355252"></p><p>上面我们用到了绝对定位，可能就会提出疑问：这不是算是绝对定位法吗？</p><p>但是上面的只是其中一种用法，也能通过搭配<code>margin</code>来实现隐藏，只要让降低层次的元素被更高层次的元素遮住就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">div:nth-child(2) &#123;<br>    margin-left: -100px;<br>    z-index: -999;<br>    background-color: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>z-index</code>不会导致回流，但是会导致重绘，因为<code>z-index</code>只是降低层级，并不会导致几何位置的变化。</p><p>但是，如果像上面那样搭配<code>position</code>、<code>margin</code>使用，则会导致回流。</p><h2 id="clip-path法"><a href="#clip-path法" class="headerlink" title="clip-path法"></a>clip-path法</h2><blockquote><p><code>clip-path</code>：使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</p></blockquote><p>只需要把元素的可显示区域裁剪为0即可，会保留位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">div:nth-child(2) &#123;<br>    clip-path: circle(0);<br>    background-color: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe66c61e1b374c319b93c206edc9aafc~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220428220242817"></p><p><code>clip-path</code>不会导致回流，但是会导致重绘</p><p>\</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS隐藏元素的几种方式&quot;&gt;&lt;a href=&quot;#CSS隐藏元素的几种方式&quot; class=&quot;headerlink&quot; title=&quot;CSS隐藏元素的几种方式&quot;&gt;&lt;/a&gt;CSS隐藏元素的几种方式&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Element Plus修改表格行、单元格样式</title>
    <link href="https://www.clzczh.top/2022/04/30/vue-element%E8%A1%A8%E6%A0%BC/"/>
    <id>https://www.clzczh.top/2022/04/30/vue-element%E8%A1%A8%E6%A0%BC/</id>
    <published>2022-04-30T09:24:29.000Z</published>
    <updated>2022-05-18T14:10:11.474Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="theme-channing-cyan"><a href="#theme-channing-cyan" class="headerlink" title="theme: channing-cyan"></a>theme: channing-cyan</h2><p>一起养成写作习惯！这是我参与「掘金日新计划 · 4 月更文挑战」的第27天，<a href="https://juejin.cn/post/7080800226365145118" title="https://juejin.cn/post/7080800226365145118">点击查看活动详情</a>。</p><h1 id="Element-Plus修改表格行、单元格样式"><a href="#Element-Plus修改表格行、单元格样式" class="headerlink" title="Element Plus修改表格行、单元格样式"></a>Element Plus修改表格行、单元格样式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实习工作需要根据表格的状态字段来设置行的样式，记录一波。</p><p>先来一下基础配置。(Vue3)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">el-table</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;tableData&quot;</span> <span class="hljs-attr">border</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 400px&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;姓名&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;年龄&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;job&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;工作&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">el-table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">const</span> tableData = [</span><br><span class="javascript">  &#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;clz&quot;</span>,</span><br><span class="javascript">    <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>,</span><br><span class="javascript">    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Coder&quot;</span>,</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  &#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;czh&quot;</span>,</span><br><span class="javascript">    <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>,</span><br><span class="javascript">    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Coder&quot;</span>,</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  &#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;赤蓝紫&quot;</span>,</span><br><span class="javascript">    <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>,</span><br><span class="javascript">    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Coder&quot;</span>,</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">];</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/631eedb6885c44babc3af2a9e48b3642~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220425211149555"></p><h2 id="设置某一行的样式"><a href="#设置某一行的样式" class="headerlink" title="设置某一行的样式"></a>设置某一行的样式</h2><p>主要是通过<code> row-style</code>属性来实现。它是行的<code> style</code>的回调方法，可以通过它来实现设置某一行的样式。</p><p>先让我们来体验一下它的参数都是些什么。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-table</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 400px&quot;</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">border</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;tableData&quot;</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">:row-style</span>=<span class="hljs-string">&quot;rowState&quot;</span></span><br><span class="hljs-tag">&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">el-table</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rowState = <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(arg)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/644e485b23d34bd1a2867b2c1a7911e4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220425213221090"></p><p>可以发现，它是一个对象，一个属性是行的数据，一个是行号(从0开始)，至于不只是打印3次，而是打印9次的原因还没发现，后面单元格的会打印18次，9个单元格打印18次。但是这个并不是本次的研究重点。</p><p>那么，我们怎样能设置样式呢？</p><p>只需要返回含有属性样式的对象即可。(<strong>驼峰命名法</strong>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rowState = <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;pink&#x27;</span>,<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#fff&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82c6c7eb457c4a96b53f91f4248ccb0b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220425213934820"></p><p>然后在搭配参数使用，就能实现根据表格内容设置行的样式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rowState = <span class="hljs-function">(<span class="hljs-params">&#123; row &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> style = &#123;&#125;<br><br>  <span class="hljs-keyword">switch</span> (row.name) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;clz&#x27;</span>:<br>      style = &#123;<br>        <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;red&#x27;</span><br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;czh&#x27;</span>:<br>      style = &#123;<br>        <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;blue&#x27;</span><br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;赤蓝紫&#x27;</span>:<br>      style = &#123;<br>        <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;purple&#x27;</span><br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> style;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/clzczh/picgo/raw/master/images/202205182210732.png" alt="image-20220426211744236"></p><h2 id="设置某一个单元格的样式"><a href="#设置某一个单元格的样式" class="headerlink" title="设置某一个单元格的样式"></a>设置某一个单元格的样式</h2><p>通过<code> cell-style</code>属性来实现。做法和上面一样，就不多说了，主要的四个参数<code> row, column, rowIndex, columnIndex</code>。</p><ul><li><code>row</code>：行的信息</li><li><code>column</code>：列的信息</li><li><code>rowIndex</code>： 行数(0开始算)</li><li><code>columnIndex</code>：列数(0开始算)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-table</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 400px&quot;</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">border</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;tableData&quot;</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">:cell-style</span>=<span class="hljs-string">&quot;cellStyle&quot;</span></span><br><span class="hljs-tag">&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">el-table</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cellStyle = <span class="hljs-function">(<span class="hljs-params">&#123; row, column, rowIndex, columnIndex &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (rowIndex === <span class="hljs-number">1</span> &amp;&amp; columnIndex === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;pink&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04e946b91a5f44d2b83b7603b8d40b6e~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220426232712515"></p><p>其实，<code>cell-state</code>不只是能设置单元格的样式，因为它的参数中含有<code> row</code>和<code> column</code>，所以还可以用来设置某一行或某一列的样式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cellStyle = <span class="hljs-function">(<span class="hljs-params">&#123; row, column, rowIndex, columnIndex &#125;</span>) =&gt;</span> &#123;<br><br>  <span class="hljs-keyword">if</span> (column.label === <span class="hljs-string">&#x27;工作&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;purple&#x27;</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (row.name === <span class="hljs-string">&#x27;赤蓝紫&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;red&#x27;</span><br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfccea39d66f4b4c8045e21c29712fb3~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220426233521464"></p><p><b style="color: red">注意，这里重叠的地方并不会出现后来的样式覆盖掉前面的样式，而是先到先得</b></p><h2 id="表头样式修改-赠品"><a href="#表头样式修改-赠品" class="headerlink" title="表头样式修改(赠品)"></a>表头样式修改(赠品)</h2><p>特殊的表头，特殊的处理</p><p><code>header-row-style</code>：只有一个<code>rowIndex</code>属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">const headerRowStyle = (args) =&gt; &#123;<br>  console.log(args)<br><br>  return &#123;<br>    height: &#x27;100px&#x27;,<br>    backgroundColor: &#x27;red&#x27;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ec6ae0d71a6490199c26322b3b259d7~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220427220605501"></p><p>发现只有标头的行高有所变化，这是为啥呢？</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e213d53f38334f71846e8723a640b518~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220427220742235"></p><p>检查样式发现，这是因为单元格本身具有背景颜色，所以并不会生效。</p><p><code>header-row-style</code>：和正常的单元格一样，有四个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">const headerCellStyle = (&#123; row, column, rowIndex, columnIndex &#125;) =&gt; &#123;<br>  if (columnIndex === 1) &#123;<br>    return &#123;<br>      backgroundColor: &#x27;pink&#x27;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/clzczh/picgo/raw/master/images/202205182210698.png" alt="image-20220427221737551"></p><p>也可以通过<code>column</code>属性来设置符合条件的表头单元格的样式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">const headerCellStyle = (&#123; row, column, rowIndex, columnIndex &#125;) =&gt; &#123;<br><br>  if (column.label === &#x27;姓名&#x27;) &#123;<br>    return &#123;<br>      backgroundColor: &#x27;red&#x27;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8e2ff1f91304924a85c3c421e8e2f5b~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220427222630382"></p><p>\</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;theme-channing-cyan&quot;&gt;&lt;a href=&quot;#theme-channing-cyan&quot; class=&quot;headerlink&quot; title=&quot;theme: channing-cyan&quot;&gt;&lt;/a&gt;theme: channing-cyan&lt;/h</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Vue3" scheme="https://www.clzczh.top/tags/Vue3/"/>
    
    <category term="Element" scheme="https://www.clzczh.top/tags/Element/"/>
    
  </entry>
  
  <entry>
    <title>创建对象的几种方式(二)</title>
    <link href="https://www.clzczh.top/2022/04/30/js-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A12/"/>
    <id>https://www.clzczh.top/2022/04/30/js-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A12/</id>
    <published>2022-04-30T09:23:19.000Z</published>
    <updated>2022-04-30T09:23:48.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建对象的几种方式-二"><a href="#创建对象的几种方式-二" class="headerlink" title="创建对象的几种方式(二)"></a>创建对象的几种方式(二)</h1><blockquote><p>看红宝书+查资料，重新梳理JavaScript的知识。</p></blockquote><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型的知识不会过多赘述，可以查看我之前写的文章，或者自己找资料。</p><p>每个函数都会创建一个<code>prototype</code>属性，它就是原型对象，在它上面定义的属性和方法可以被对象实例共享。所以在构造函数中赋值给对象的值，可以变成赋值给它们的原型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123; &#125;<br><br>Person.prototype.name = <span class="hljs-string">&#x27;clz&#x27;</span>;<br>Person.prototype.age = <span class="hljs-number">21</span>;<br>Person.prototype.listen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Egoist&#x27;</span>);<br>&#125;<br><br><br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> Person();<br><br><span class="hljs-built_in">console</span>.log(person1.name, person1.age)  <span class="hljs-comment">// clz 21</span><br><br><span class="hljs-built_in">console</span>.log(person1.listen === person2.listen);      <span class="hljs-comment">// true</span><br><br>person1.listen();        <span class="hljs-comment">// Egoist</span><br></code></pre></td></tr></table></figure><p>但是，这时候直接打印实例，如<code> person1</code>，会得到一个空对象和内部属性<code>[[Prototype]]</code>，因为它的属性和方法都在原型对象上。</p><h3 id="手动设置原型"><a href="#手动设置原型" class="headerlink" title="手动设置原型"></a>手动设置原型</h3><p><strong>可以通过<code>Object.setPrototypeOf</code>来手动设置原型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> father = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">21</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.setPrototypeOf(person, father);<br><br><span class="hljs-built_in">console</span>.log(person.age)     <span class="hljs-comment">// 21</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(person) === father)   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>但是，使用<code>Object.setPrototypeOf</code>可能会严重影响代码性能，因为</p><blockquote><p>修改继承关系的影响时微妙而深远的，它的影响会涉及<strong>所有访问了那些修改过<code>[[Prototype]]</code>的对象的代码</strong>。</p></blockquote><p>可以通过<code>Object.create</code>来创建一个新对象，并同时为其指定原型。这样子可以避免使用<code>Object.setPrototypeOf</code>可能造成的性能下降。(因为此时的新对象还没有任何属性，修改它的原型对象造成的影响很明显会小一点)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> father = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">21</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-built_in">Object</span>.create(father);<br>person.name = <span class="hljs-string">&#x27;clz&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(person)         <span class="hljs-comment">// &#123; name: &#x27;clz&#x27; &#125;</span><br><span class="hljs-built_in">console</span>.log(person.age)     <span class="hljs-comment">// 21</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(person) === father)       <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h3><p>既然实例可以通过原型链访问到原型对象的属性，那么我们就需要知道什么属性是实例自身的，还是原型对象上的。这时候我们就可以使用<code> hasOwnProperty</code>来确定某个属性是在实例上还是在原型对象上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;<br><br>Person.prototype.name = <span class="hljs-string">&#x27;czh&#x27;</span><br>Person.prototype.age = <span class="hljs-number">21</span><br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person()<br><br><span class="hljs-built_in">console</span>.log(person.hasOwnProperty(<span class="hljs-string">&#x27;name&#x27;</span>))  <span class="hljs-comment">// true。来自实例</span><br><span class="hljs-built_in">console</span>.log(person.hasOwnProperty(<span class="hljs-string">&#x27;age&#x27;</span>))  <span class="hljs-comment">// false。来自原型</span><br><br><span class="hljs-keyword">delete</span> person.name  <span class="hljs-comment">// 删除掉person.name后，原型上name的属性的联系就恢复了</span><br><span class="hljs-built_in">console</span>.log(person.name)        <span class="hljs-comment">// czh</span><br><span class="hljs-built_in">console</span>.log(person.hasOwnProperty(<span class="hljs-string">&#x27;name&#x27;</span>))  <span class="hljs-comment">// false。来自原型</span><br><br><span class="hljs-keyword">delete</span> person.age   <span class="hljs-comment">// 无法通过删除实例上的属性去删除原型上的属性</span><br><span class="hljs-built_in">console</span>.log(person.age)  <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><h3 id="原型和in操作符"><a href="#原型和in操作符" class="headerlink" title="原型和in操作符"></a>原型和in操作符</h3><p>in操作符只存在于<code>for-in</code>循环？<br>不不不，in操作符不只是能在<code>for-in</code>循环中使用，还能单独使用。</p><p>单独使用时，<code>in</code>操作符在能通过对象访问指定属性时返回true，无论它是在实例上还是在原型上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;<br><br>Person.prototype.name = <span class="hljs-string">&#x27;czh&#x27;</span><br>Person.prototype.age = <span class="hljs-number">21</span><br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person()<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> person)  <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> person)  <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;job&#x27;</span> <span class="hljs-keyword">in</span> person)    <span class="hljs-comment">// false。无法通过对象访问到属性才会为false</span><br></code></pre></td></tr></table></figure><h3 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h3><blockquote><p><code>for-in</code>循环和<code>Object.keys()</code>的枚举顺序是不确定的，取决于JavaScript引擎，可能会因浏览器而异。</p></blockquote><p><code>Object.getOwnPropertyNames()</code>返回对象实例的常规属性数组，<code>Object.getOwnPropertySymbols()</code>返回对象实例的符号属性数组。</p><p><code>Object.getOwnPropertyNames()</code>枚举顺序：</p><ol><li>按升序枚举数值键</li><li>字面量中定义的键以出现顺序来枚举</li><li>插入的键(不包括数值键)以插入顺序来枚举</li><li>不会枚举符号键</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> k1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;k1&#x27;</span>)<br><span class="hljs-keyword">const</span> k2 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;k2&#x27;</span>)<br><br><span class="hljs-keyword">let</span> o = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">0</span>,<br>    [k1]: <span class="hljs-string">&#x27;k1&#x27;</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-string">&#x27;c&#x27;</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<br>    <span class="hljs-attr">C</span>: <span class="hljs-string">&#x27;C&#x27;</span>,<br>    <span class="hljs-attr">B</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>&#125;<br><br>o[k2] = <span class="hljs-string">&#x27;k2&#x27;</span><br>o[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br>o.a = <span class="hljs-string">&#x27;a&#x27;</span><br>o.A = <span class="hljs-string">&#x27;A&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyNames(o))   <span class="hljs-comment">// [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;C&#x27;, &#x27;B&#x27;, &#x27;a&#x27;, &#x27;A&#x27;]</span><br><br></code></pre></td></tr></table></figure><p>需要枚举符号属性的话，用<code>getOwnPropertySymbols</code>。符号属性的枚举比较简单暴力：谁先出现枚举谁。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> k1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br><span class="hljs-keyword">const</span> k2 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;2&#x27;</span>)<br><br><span class="hljs-keyword">const</span> k3 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-keyword">const</span> k4 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br><br><span class="hljs-keyword">const</span> k5 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;3&#x27;</span>)<br><span class="hljs-keyword">const</span> k6 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;b&#x27;</span>)<br><br><span class="hljs-keyword">let</span> o = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">0</span>,<br>    [k3]: <span class="hljs-string">&#x27;c&#x27;</span>,<br>    [k1]: <span class="hljs-string">&#x27;1&#x27;</span>,<br>    [k2]: <span class="hljs-string">&#x27;2&#x27;</span>,<br>    [k4]: <span class="hljs-string">&#x27;a&#x27;</span><br>&#125;<br><br>o[k5] = <span class="hljs-string">&#x27;3&#x27;</span><br>o[k6] = <span class="hljs-string">&#x27;b&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertySymbols(o))   <span class="hljs-comment">// [ Symbol(c), Symbol(1), Symbol(2), Symbol(a), Symbol(3), Symbol(b) ]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建对象的几种方式-二&quot;&gt;&lt;a href=&quot;#创建对象的几种方式-二&quot; class=&quot;headerlink&quot; title=&quot;创建对象的几种方式(二)&quot;&gt;&lt;/a&gt;创建对象的几种方式(二)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;看红宝书+查资料，重新梳理JavaSc</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>创建对象的几种方式(一)</title>
    <link href="https://www.clzczh.top/2022/04/30/js-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A11/"/>
    <id>https://www.clzczh.top/2022/04/30/js-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A11/</id>
    <published>2022-04-30T09:22:39.000Z</published>
    <updated>2022-04-30T09:23:11.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建对象的几种方式-一"><a href="#创建对象的几种方式-一" class="headerlink" title="创建对象的几种方式(一)"></a>创建对象的几种方式(一)</h1><blockquote><p>看红宝书+查资料，重新梳理JavaScript的知识。</p></blockquote><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>首先需要一个函数(工厂)，然后在函数中创建具体对象。这种模式可以抽象创建具体对象的过程，这样子，我们想要创建对象，只需要调用函数，让属性值进厂即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPerson</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br>    o.name = name;<br>    o.age = age;<br>    o.listen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Egoist&#x27;</span>)<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br><br><span class="hljs-keyword">const</span> person1 = createPerson(<span class="hljs-string">&#x27;clz&#x27;</span>, <span class="hljs-number">21</span>);<br><span class="hljs-keyword">const</span> person2 = createPerson(<span class="hljs-string">&#x27;czh&#x27;</span>, <span class="hljs-number">111</span>);<br><br><span class="hljs-built_in">console</span>.log(person1);   <span class="hljs-comment">// &#123;name: &#x27;clz&#x27;, age: 21, listen: ƒ&#125;</span><br><span class="hljs-built_in">console</span>.log(person2);   <span class="hljs-comment">// &#123;name: &#x27;czh&#x27;, age: 111, listen: ƒ&#125;</span><br><br>person1.listen();       <span class="hljs-comment">// Egoist</span><br></code></pre></td></tr></table></figure><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>ECMAScript中的构造函数是用于创建特定类型对象的。所以我们可以通过自定义构造函数，以函数的形式来为对象定义属性和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.listen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Egoist&#x27;</span>)<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;clz&#x27;</span>, <span class="hljs-number">21</span>);<br><span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;czh&#x27;</span>, <span class="hljs-number">111</span>);<br><br><span class="hljs-built_in">console</span>.log(person1);   <span class="hljs-comment">// &#123;name: &#x27;clz&#x27;, age: 21, listen: ƒ&#125;</span><br><span class="hljs-built_in">console</span>.log(person2);   <span class="hljs-comment">// &#123;name: &#x27;czh&#x27;, age: 111, listen: ƒ&#125;</span><br><br>person1.listen();       <span class="hljs-comment">// Egoist</span><br></code></pre></td></tr></table></figure><p>此时，我们不再需要通过原生构造函数<code>Object</code>来显示地创建对象，而是直接通过<code>this</code>关键字来实现，也不再需要把创建的对象<code>return</code>出去。但是，构造函数和普通函数的使用方式也不太一样，需要通过<code>new</code>操作符来<code>new</code>出一个对象。</p><p><strong>构造函数名称的首字母需要大写，非构造函数以小写字母开头</strong>。不这样子虽然也可以，但是按照规范，才能更好地区分构造函数和普通函数。</p><p>构造函数和普通函数的使用方式不太一样，需要使用<code>new</code>操作符。</p><p>为什么需要这样子的方式调用构造函数呢？<br>因为以这样的方式调用函数会执行以下操作：</p><ol><li>在内存中创建一个新对象</li><li>新对象的<code> __proto__</code>指向构造函数的原型<code>prototype</code>(具体可以查看之前的写的原型链文章)</li><li>构造函数内部的<code>this</code>指向新对象</li><li>执行构造函数内的代码</li><li>如果构造函数返回非空对象，则返回该对象；否则返回在内存中创建的那个对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">person</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.listen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Egoist&#x27;</span>)<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">999</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> person(<span class="hljs-string">&#x27;clz&#x27;</span>, <span class="hljs-number">21</span>);<br><br><span class="hljs-built_in">console</span>.log(person1);   <span class="hljs-comment">// &#123; name: &#x27;clz&#x27;, age: 999 &#125;</span><br></code></pre></td></tr></table></figure><h3 id="构造函数也是函数"><a href="#构造函数也是函数" class="headerlink" title="构造函数也是函数"></a>构造函数也是函数</h3><p>如果构造函数不使用<code>new</code>操作符来调用，就是普通函数。这时候，添加的属性、方法会被添加到全局对象上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.listen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Egoist&#x27;</span>)<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> person1 = Person(<span class="hljs-string">&#x27;clz&#x27;</span>, <span class="hljs-number">21</span>);<br><br><span class="hljs-built_in">console</span>.log(person1)            <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(globalThis.name);   <span class="hljs-comment">// clz</span><br><span class="hljs-built_in">console</span>.log(globalThis.age);    <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><p>上面使用了<code>globalThis</code>。<code>globalThis</code>是全局对象的标准名称。<br>因为在浏览器中，全局对象是window，而在Node.js中，全局对象是<code>global</code>。但是在浏览器中，访问<code> global</code>会报错，在Node.js中，访问<code> window</code>也会报错。使用<code>globalThis</code>就不会出现这个问题，简单来说的话，就是<code>globalThis</code>会变身，在浏览器时，会变成<code>window</code>，在Node.js时，会变成<code>global</code></p><p>上面给对象添加方法等价于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.listen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;console.log(&quot;Egoist&quot;)&#x27;</span>)<br></code></pre></td></tr></table></figure><p>也就是说，不同实例上的函数同名但不相等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(person1.listen === person2.listen)  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>但是呢？都是干一样的事，却要定义两个不同的<code>Function</code>实例，这很明显很不合理，毕竟如果需要100个实例，那就需要100个<code>Function</code>实例。所以，应该先在外面声明函数，然后才把声明的函数赋给实例的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.listen = listen<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listen</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Egoist&quot;</span>);<br>&#125;<br><br><br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;clz&#x27;</span>, <span class="hljs-number">21</span>);<br><span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;clz&#x27;</span>, <span class="hljs-number">111</span>);<br><br><span class="hljs-built_in">console</span>.log(person1.listen === person2.listen)      <span class="hljs-comment">// true</span><br><br>person1.listen()        <span class="hljs-comment">// Egoist</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建对象的几种方式-一&quot;&gt;&lt;a href=&quot;#创建对象的几种方式-一&quot; class=&quot;headerlink&quot; title=&quot;创建对象的几种方式(一)&quot;&gt;&lt;/a&gt;创建对象的几种方式(一)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;看红宝书+查资料，重新梳理JavaSc</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之对象(二)</title>
    <link href="https://www.clzczh.top/2022/04/30/js-%E5%AF%B9%E8%B1%A12/"/>
    <id>https://www.clzczh.top/2022/04/30/js-%E5%AF%B9%E8%B1%A12/</id>
    <published>2022-04-30T09:21:57.000Z</published>
    <updated>2022-04-30T09:22:20.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript之对象-二"><a href="#JavaScript之对象-二" class="headerlink" title="JavaScript之对象(二)"></a>JavaScript之对象(二)</h1><blockquote><p>看红宝书+查资料，重新梳理JavaScript的知识。</p></blockquote><h2 id="合并对象-Object-assign"><a href="#合并对象-Object-assign" class="headerlink" title="合并对象 Object.assign()"></a>合并对象<code> Object.assign()</code></h2><p><code> Object.assign()</code>可以用来将原对象的属性合并到目标对象上，而且这个方法还会返回合并后的目标对象。它会使用源对象上的<code>[[Get]]</code>取得属性的值，然后使用目标对象上的<code>[[Set]]</code>设置属性的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> target = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> source = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">21</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// 也会返回修改后的目标对象</span><br>result = <span class="hljs-built_in">Object</span>.assign(target, source);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;target: &#x27;</span>, target);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;source: &#x27;</span>, source);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;result: &#x27;</span>, result);<br><br><span class="hljs-built_in">console</span>.log(target === result);<br></code></pre></td></tr></table></figure><h3 id="合并对象是浅克隆"><a href="#合并对象是浅克隆" class="headerlink" title="合并对象是浅克隆"></a>合并对象是浅克隆</h3><p>合并对象是浅克隆。所以如果合并的属性是对象，那么修改源对象会修改到目标对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> target = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> source = &#123;<br>    <span class="hljs-attr">job</span>: &#123;<br>        <span class="hljs-attr">salary</span>: <span class="hljs-number">1</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">Object</span>.assign(target, source);<br><br>source.job.salary = <span class="hljs-number">999</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;target: &#x27;</span>, target)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;source&#x27;</span>, source)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/clzczh/picgo/raw/master/images/202204301722309.png" alt="image-20220423200456546"></p><h3 id="多个源对象合并"><a href="#多个源对象合并" class="headerlink" title="多个源对象合并"></a>多个源对象合并</h3><p>上面的例子中，<code>Object.assign</code>只接收了两个参数，第一个参数是目标对象，第二个参数是源对象。但是呢，其实它并不只是能够接收两个参数，可以接收多个参数，第一个参数是目标对象，其他的都是源对象，都会合并到目标对象上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> target = &#123;&#125;;<br><span class="hljs-keyword">let</span> source1 = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;;<br><span class="hljs-keyword">let</span> source2 = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">19</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.assign(target, source1, source2);<br><span class="hljs-built_in">console</span>.log(target);<span class="hljs-comment">// &#123;name: &#x27;clz&#x27;, age: 19&#125;</span><br></code></pre></td></tr></table></figure><p>既然存在多个源对象合并，那么问题来了，如果多个源对象具有相同的属性时，会怎样呢？</p><p>多个源对象具有相同的属性时，会使用最后的那个属性值。实际过程就是从左往右合并对象，可以通过在目标对象上添加<code> set</code>函数观察过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> target, source1, source2, source3;<br><br>target = &#123;<br>    <span class="hljs-keyword">set</span> <span class="hljs-title">job</span>(<span class="hljs-params">newValue</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(newValue)<br>    &#125;<br>&#125;;<br><br>source1 = &#123;<br>    <span class="hljs-attr">job</span>: &#123;<br>        <span class="hljs-attr">salary</span>: <span class="hljs-number">20</span>,<br>    &#125;,<br>&#125;;<br><br>source2 = &#123;<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;WebMaster&quot;</span>,<br>&#125;;<br><br>source3 = &#123;<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Coder&quot;</span>,<br>&#125;;<br><br><span class="hljs-built_in">Object</span>.assign(target, source1, source2, source3);<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bcd9157883f4683aa9bc1cb028bddac~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220423204031530"></p><h2 id="相等判定Object-is"><a href="#相等判定Object-is" class="headerlink" title="相等判定Object.is()"></a>相等判定<code>Object.is()</code></h2><p>ES6 之前的相等判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(+<span class="hljs-number">0</span> === -<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(+<span class="hljs-number">0</span> === <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(-<span class="hljs-number">0</span> === <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// true，要验证NaN的相等性需要使用isNaN</span><br></code></pre></td></tr></table></figure><p>问题所在：</p><ol><li>+0、0会等于-0</li><li><code>NaN</code>不等于<code>NaN</code>，验证<code> NaN</code>的相等性需要换方法：使用<code>isNaN</code>函数</li></ol><p>ES6 新增<code>Object.is()</code>，和<code> ===</code>很像，但是能更好的应对特殊情况。从下面的例子可以看出，<code>===</code>本来的功能它有，还能很好的应对上面说的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.is(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.is(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.is(+<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.is(+<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.is(-<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="属性名简写"><a href="#属性名简写" class="headerlink" title="属性名简写"></a>属性名简写</h3><p><strong>常用</strong></p><p>当属性名和变量名相同时，我们可以使用简写。因为它会自动去找同名变量。如果找不到，则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> age = <span class="hljs-number">21</span>;<br><span class="hljs-keyword">const</span> person = &#123;<br>    age, <span class="hljs-comment">// 当属性名和变量名一样时，可以简写。会自动去找同名变量。如果找不到，则会报错</span><br>    <span class="hljs-comment">// age: age</span><br>&#125;;<br><br><span class="hljs-built_in">console</span>.log(person);    <span class="hljs-comment">// &#123;age: 21&#125;</span><br></code></pre></td></tr></table></figure><p>方法算是特殊的属性，也能简写。实际上，简写版本很常见</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-comment">// listen: function () &#123;</span><br>    <span class="hljs-comment">//     console.log(&#x27;Euterpe&#x27;)</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-function"><span class="hljs-title">listen</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Euterpe&quot;</span>);<br>    &#125;,<br>&#125;;<br><br>person.listen();    <span class="hljs-comment">// Euterpe</span><br></code></pre></td></tr></table></figure><h3 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h3><p>引入可计算属性之前</p><p>我们现在有两个变量：<code> nameKey</code>和<code> ageKey</code>。想要让它的值作为对象的属性名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nameKey = <span class="hljs-string">&quot;name&quot;</span>;<br><span class="hljs-keyword">const</span> ageKey = <span class="hljs-string">&quot;age&quot;</span>;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">nameKey</span>: <span class="hljs-string">&#x27;clz&#x27;</span>,<br>    <span class="hljs-attr">ageKey</span>: <span class="hljs-number">21</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(person)     <span class="hljs-comment">// &#123;nameKey: &#x27;clz&#x27;, ageKey: 21&#125;</span><br></code></pre></td></tr></table></figure><p>发现，结果和我们想象中的不太一样。</p><p>这个时候，如果想要实现我们想要的效果，只能够使用下标的形式，因为只有下标形式才会去找变量的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nameKey = <span class="hljs-string">&quot;name&quot;</span>;<br><span class="hljs-keyword">const</span> ageKey = <span class="hljs-string">&quot;age&quot;</span>;<br><br><span class="hljs-comment">// let person = &#123;&#125;</span><br><span class="hljs-comment">// person.nameKey = &#x27;clz&#x27;</span><br><span class="hljs-comment">// person.ageKey = 21</span><br><br><span class="hljs-comment">// console.log(person)     // &#123;nameKey: &#x27;clz&#x27;, ageKey: 21&#125;</span><br><br><span class="hljs-keyword">let</span> person = &#123;&#125;;<br>person[nameKey] = <span class="hljs-string">&quot;clz&quot;</span>;<br>person[ageKey] = <span class="hljs-number">21</span>;<br><span class="hljs-built_in">console</span>.log(person);       <span class="hljs-comment">// &#123;name: &#x27;clz&#x27;, age: 21&#125;</span><br></code></pre></td></tr></table></figure><p>引入可计算属性之后，可以直接在对象字面量中<strong>直接动态命名属性</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nameKey = <span class="hljs-string">&quot;name&quot;</span>;<br><span class="hljs-keyword">const</span> ageKey = <span class="hljs-string">&quot;age&quot;</span>;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>  [nameKey]: <span class="hljs-string">&quot;clz&quot;</span>,<br>  [ageKey]: <span class="hljs-number">21</span>,<br>&#125;;<br><span class="hljs-built_in">console</span>.log(person); <span class="hljs-comment">// &#123;name: &#x27;clz&#x27;, age: 21&#125;</span><br></code></pre></td></tr></table></figure><p>简写方法名可以和可计算属性搭配使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> methodKey = <span class="hljs-string">&quot;listen&quot;</span>;<br><span class="hljs-keyword">let</span> person = &#123;<br>  [methodKey]() &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Euterpe&quot;</span>);<br>  &#125;,<br>&#125;;<br><br>person.listen();<span class="hljs-comment">// Euterpe</span><br></code></pre></td></tr></table></figure><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p><strong>常用</strong>，通过<code> &#123;a&#125; = obj</code>的形式，从<code> obj</code>中取出属性a的值，赋值给左边的a。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;clz&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>,<br>&#125;;<br><br><span class="hljs-comment">// 对象解构</span><br><span class="hljs-keyword">const</span> &#123; name, age &#125; = person;<br><span class="hljs-built_in">console</span>.log(name, age);<br></code></pre></td></tr></table></figure><p>对象解构支持重命名，<code> &#123;value: newValue&#125; = obj</code>，不过此时，<code> name</code>并不会有值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对象解构重命名</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">name</span>: myname, <span class="hljs-attr">age</span>: myage &#125; = person;<br><span class="hljs-built_in">console</span>.log(myname, myage);<br></code></pre></td></tr></table></figure><p>如果解构赋值的属性不存在，那么该变量的值就是<code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 如果解构赋值的属性不存在，那么该变量的值就是undefined</span><br><span class="hljs-keyword">const</span> &#123; job &#125; = person;<br><span class="hljs-built_in">console</span>.log(job);<span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>解构赋值支持定义默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义默认值，当解构赋值的属性不存在时，该变量的值就是默认值</span><br><span class="hljs-keyword">const</span> &#123; myjob = <span class="hljs-string">&quot;Coder&quot;</span> &#125; = person;<br><span class="hljs-built_in">console</span>.log(myjob);<br></code></pre></td></tr></table></figure><p>对象解构会把原始值当成对象。**<code>null</code>和<code>undefined</code>不能被解构<strong>，之前的</strong>解构赋值的属性不存在，那么该变量的值就是<code>undefined</code>**对<code> null</code>和<code> undefined</code>不成立，会直接报错，如<code>Cannot destructure property &#39;_&#39; of &#39;null&#39; as it is null.</code></p><h3 id="先声明后解构赋值"><a href="#先声明后解构赋值" class="headerlink" title="先声明后解构赋值"></a>先声明后解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">21</span><br>&#125;<br><br><span class="hljs-keyword">let</span> name, age<br><br>&#123; name, age &#125;   = person    <span class="hljs-comment">// 报错，`Uncaught SyntaxError: Unexpected token &#x27;=&#x27;`</span><br></code></pre></td></tr></table></figure><p>那么，是不是不能先声明，后解构复制呢？<br>答案是可以的，只不过，此时赋值表达式需要包含在一对括号里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;clz&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>,<br>&#125;;<br><br><span class="hljs-keyword">let</span> name, age;<br><br>(&#123; name, age &#125; = person);<br><br><span class="hljs-built_in">console</span>.log(name, age);     <span class="hljs-comment">// clz 21</span><br></code></pre></td></tr></table></figure><p>不只是小括号可以，使用中括号也可以，不过使用花括号就会报错了，因为解构赋值就是用的花括号</p><h3 id="解构赋值支持嵌套结构"><a href="#解构赋值支持嵌套结构" class="headerlink" title="解构赋值支持嵌套结构"></a>解构赋值支持嵌套结构</h3><p>同理，第一层不会有结果，可以打印<code>job</code>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">job</span>: &#123;<br>        <span class="hljs-attr">salary</span>: <span class="hljs-number">112</span>,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-attr">job</span>: &#123; salary &#125;,<br>&#125; = person;<br><span class="hljs-built_in">console</span>.log(salary);    <span class="hljs-comment">// 112</span><br></code></pre></td></tr></table></figure><h3 id="部分解构"><a href="#部分解构" class="headerlink" title="部分解构"></a>部分解构</h3><p>部分解构：如果一个解构表达式多个赋值，开始的赋值成功，而中间的赋值出错的话，解构赋值开始的部分还是能完成，只是中间报错的部分以及后面的部分不能完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;clz&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>,<br>&#125;;<br><br><span class="hljs-keyword">let</span> personName;<br><span class="hljs-keyword">let</span> personFoo;<br><span class="hljs-keyword">let</span> personAge;<br><br><span class="hljs-keyword">try</span> &#123;<br>  (&#123;<br>    <span class="hljs-attr">name</span>: personName,<br>    <span class="hljs-comment">// 因为personFoo没有bar属性，所以会报错</span><br>    <span class="hljs-attr">bar</span>: personFoo.bar,<br>    <span class="hljs-attr">age</span>: personAge,<br>  &#125; = person);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-built_in">console</span>.log(e);<br>&#125;<br><span class="hljs-built_in">console</span>.log(personName, personAge, personFoo);<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05a41edeb8b945c8b9505a76d376709c~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220423211723147"></p><h3 id="参数上下文匹配"><a href="#参数上下文匹配" class="headerlink" title="参数上下文匹配"></a>参数上下文匹配</h3><p>在函数参数中也可以进行解构赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;clz&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span>,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest1</span>(<span class="hljs-params">a, &#123; name, age &#125;, b</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<br>    <span class="hljs-built_in">console</span>.log(name, age);<br>    <span class="hljs-built_in">console</span>.log(b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest2</span>(<span class="hljs-params">&#123; name: myName, age: myAge &#125;</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(myName, myAge);<br>&#125;<br><br>mytest1(<span class="hljs-number">1</span>, person, <span class="hljs-number">2</span>);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;%c%s&quot;</span>, <span class="hljs-string">&quot;color:red;font-size:24px;&quot;</span>, <span class="hljs-string">&quot;============&quot;</span>);<br>mytest2(person);<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ae577d06d0e44f590dcc74229296ee4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220423211842229"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript之对象-二&quot;&gt;&lt;a href=&quot;#JavaScript之对象-二&quot; class=&quot;headerlink&quot; title=&quot;JavaScript之对象(二)&quot;&gt;&lt;/a&gt;JavaScript之对象(二)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;看红宝</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之对象(一)</title>
    <link href="https://www.clzczh.top/2022/04/30/js-%E5%AF%B9%E8%B1%A11/"/>
    <id>https://www.clzczh.top/2022/04/30/js-%E5%AF%B9%E8%B1%A11/</id>
    <published>2022-04-30T09:21:11.000Z</published>
    <updated>2022-04-30T09:21:47.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript之对象-一"><a href="#JavaScript之对象-一" class="headerlink" title="JavaScript之对象(一)"></a>JavaScript之对象(一)</h1><blockquote><p>看红宝书+查资料，重新梳理JavaScript的知识。</p></blockquote><h2 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h2><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性有四个特性。通过特性，可以设置属性。如通过<code>[[Enumerable]]</code>为<code>false</code>就能不让该属性被枚举。另外，为了区别是不是特殊的属性，规范会用两个中括号将特性的名称括起来，如<code>[[Writable]]</code>。</p><ul><li>  <code>[[Configurable]]</code>: 表示属性是否可以被设置。如被<code>delete</code>，以及能否修改特性等。</li><li>  <code>[[Enumerable]]</code>: 表示属性是不是可被枚举的。</li><li>  <code>[[Writable]]</code>: 表示属性的值是否能被修改</li><li>  <code>[[Value]]</code>: 表示属性实际值</li></ul><p>如果我们直接使用字面量的形式将属性显示添加到对象之后，<code>[[Configurable]]</code>、<code>[[Enumerable]]</code>、<code>[[Writable]]</code>会被设置为<code>true</code>，而<code>[[Value]]</code>特性则会被设置为指定的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">let person = &#123;<br>    name: &#x27;clz&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>设置成不可修改、不可定义的时候，修改、删除属性都不会报错，不过也不会成功，会被忽略，相当于什么都没干</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Object.defineProperty(person, &quot;name&quot;, &#123;<br>    writable: false,        // 默认值为false，所以去掉也是一样的结果<br>    configurable: false,    // 默认值为false，所以去掉也是一样的结果<br>    value: &quot;clz&quot;,<br>&#125;);<br><br>console.log(person);<br><br>person.name = &quot;czh&quot;;<br>console.log(person);<br><br>delete person.name<br>console.log(person);<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a58533c21f14c03886389c97c1da605~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220423172621243"></p><p>如果去掉上面注释的两行，也能得到一样的结果，因为默认值就是<code>false</code>。</p><p>如果设置为<code>true</code>，则结果大不相同，因为此时能够修改属性，也能够设置属性了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">let person = &#123;&#125;;<br><br>Object.defineProperty(person, &quot;name&quot;, &#123;<br>    writable: true,<br>    configurable: true,<br>    value: &quot;clz&quot;,<br>&#125;);<br><br>console.log(person);<br><br>person.name = &quot;czh&quot;;<br>console.log(person);<br><br>delete person.name<br>console.log(person);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/clzczh/picgo/raw/master/images/202204301721663.png" alt="image-20220423172933796"></p><p>上面我们可以发现，当我们设置成不可修改时，修改只是不会生效，并不会报错。所以如果我们想要修改设置为不可修改的属性的话，可以使用严格模式，此时还强行修改的话，就会报错。</p><p>能反复调用<code>Object.defineProperty</code>，但是如果那四个特性有修改就会报错，不知道有啥意义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">let person = &#123;&#125;;<br><br>Object.defineProperty(person, &quot;name&quot;, &#123;<br>  value: &quot;clz&quot;,<br>&#125;);<br>console.log(person);<br><br>Object.defineProperty(person, &quot;name&quot;, &#123;<br>  value: &quot;czh&quot;,<br>&#125;);<br>console.log(person);<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4da1ab7def374de59817f9d4beecb423~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220423170434625"></p><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><ul><li>  <code>[[Configurable]]</code></li><li>  <code>[[Enumerable]]</code></li><li>  <code>[[Get]]</code>: 获取函数，在读取属性时调用，默认值为 <code>undefined</code></li><li>  <code>[[Set]]</code>: 设置函数，在写入函数是调用，默认值是<code>undefined</code></li></ul><p><strong>访问器属性和数据属性中不重合的特性不能同时使用</strong>，比如，如果使用<code>setter</code>和<code>getter</code>，那再使用<code>writable</code>或<code>value</code>就会报错。至于为什么会报错，就是因为会有冲突，比如既设置了<code>value</code>和<code>getter</code>，那么这个时候应该怎么获取数据呢？所以多一事不如少一事，<strong>数据属性和访问器属性不重合的特性不能同时使用</strong>。(后半部分是猜想)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">let person = &#123;<br>  name_: &quot;clz&quot;,<br>&#125;;<br><br>Object.defineProperty(person, &quot;name&quot;, &#123;<br>  // writable: false,        // 互不相容，如果添加这个则会导致报错<br>  get() &#123;<br>    console.log(&quot;getter&quot;);<br>    return this.name_;<br>  &#125;,<br>  set(newValue) &#123;<br>    console.log(&quot;setter&quot;);<br>    this.name_ = newValue;<br>  &#125;,<br>&#125;);<br><br>console.log(person);<br>console.log(person.name);<br><br>console.log(&quot;%c%s&quot;, &quot;color: red;font-size:24px;&quot;, &quot;===============&quot;);<br><br>person.name = &quot;czh&quot;;<br>console.log(person);<br>console.log(person.name);<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/976e36ec3f5d4e37a2b19479a304093e~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220423171002134"></p><p>通过观察上面的例子，不难发现，在我们获取数据或者修改数据时，会进入到<code>get</code>和<code>set</code>属性中，所以通过这两个属性就能实现数据的劫持。</p><h2 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h2><p>使用<code>Object.defineProperty</code>只能定义一个属性的特殊属性。我们可以通过<code>Object.defineProperties</code>定义多个属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">let person = &#123;&#125;;<br><br>Object.defineProperties(person, &#123;<br>    name_: &#123;<br>        value: &quot;clz&quot;,<br>    &#125;,<br>    name: &#123;<br>        get() &#123;<br>            console.log(&quot;getter&quot;);<br>            return this.name_;<br>        &#125;,<br>        set(newValue) &#123;<br>            console.log(&quot;setter&quot;);<br>            this.name_ = newValue;<br>        &#125;,<br>    &#125;,<br>&#125;);<br><br>console.log(person);<br>console.log(person.name);<br><br>console.log(&quot;%c%s&quot;, &quot;color: red;font-size:24px;&quot;, &quot;===============&quot;);<br><br>person.name = &quot;czh&quot;;<br>console.log(person);<br>console.log(person.name);<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07e71537d116447e9edfc166e5235df3~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220423171726675"></p><h2 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h2><p>在上面我们已经知道怎样定义属性，以设置属性的特性了，有没有什么方法可以读取属性的特性呢？</p><p>通过<code>Object.getOwnPropertyDescriptor</code>就可以读取属性的特性，其中第一个参数是对象，第二个参数是要读取特性的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">let person = &#123;&#125;;<br>Object.defineProperties(person, &#123;<br>    name_: &#123;<br>        value: &quot;clz&quot;,<br>    &#125;,<br>    name: &#123;<br>        get: function () &#123;<br>            return this.name_;<br>        &#125;,<br>        set: function (newValue) &#123;<br>            this.name_ = newValue;<br>        &#125;,<br>    &#125;,<br>&#125;);<br><br>let descriptor = Object.getOwnPropertyDescriptor(person, &quot;name_&quot;);<br>console.log(descriptor);<br><br>descriptor = Object.getOwnPropertyDescriptor(person, &quot;name&quot;);<br>console.log(descriptor);<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d763f617556481aae104e4afa8c2c19~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220423191037056"></p><p>通过<code>Object.getOwnPropertyDescriptors(person)</code>可以获取所有属性的特性(对象形式)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">let person = &#123;&#125;;<br>Object.defineProperties(person, &#123;<br>    name_: &#123;<br>        value: &quot;clz&quot;,<br>    &#125;,<br>    name: &#123;<br>        get: function () &#123;<br>            return this.name_;<br>        &#125;,<br>        set: function (newValue) &#123;<br>            this.name_ = newValue;<br>        &#125;,<br>    &#125;,<br>&#125;);<br><br>let descriptors = Object.getOwnPropertyDescriptors(person);<br>console.log(descriptors);<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62a6fb85c8f045209b570c19f72355c3~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220423191225329"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript之对象-一&quot;&gt;&lt;a href=&quot;#JavaScript之对象-一&quot; class=&quot;headerlink&quot; title=&quot;JavaScript之对象(一)&quot;&gt;&lt;/a&gt;JavaScript之对象(一)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;看红宝</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之函数(二) 函数内部三个不常见的属性</title>
    <link href="https://www.clzczh.top/2022/04/30/js-%E5%87%BD%E6%95%B0%E4%BA%8C/"/>
    <id>https://www.clzczh.top/2022/04/30/js-%E5%87%BD%E6%95%B0%E4%BA%8C/</id>
    <published>2022-04-30T09:20:21.000Z</published>
    <updated>2022-04-30T09:20:44.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript之函数-二-函数内部三个不常见的属性"><a href="#JavaScript之函数-二-函数内部三个不常见的属性" class="headerlink" title="JavaScript之函数(二) 函数内部三个不常见的属性"></a>JavaScript之函数(二) 函数内部三个不常见的属性</h1><blockquote><p>看红宝书+查资料，重新梳理JavaScript的知识。</p></blockquote><h2 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a>arguments.callee</h2><p><code>arguments</code>就不多说了，但是<code>arguments</code>有一个<code>callee</code>属性，是一个指向<code>arguments</code>对象所在函数的指针。</p><p>先来一下阶乘函数看看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> num * factorial(num - <span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(factorial(<span class="hljs-number">4</span>))       <span class="hljs-comment">// 24</span><br></code></pre></td></tr></table></figure><p>这样一看，是没什么问题的。</p><p>但是上面的函数必须要保证函数名是<code>factorial</code>，导致了紧密耦合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> num * factorial(num - <span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> copyFactorial = factorial<br><br><span class="hljs-built_in">console</span>.log(copyFactorial(<span class="hljs-number">4</span>))       <span class="hljs-comment">// 24</span><br></code></pre></td></tr></table></figure><p>还是没有问题？<br>这里没有问题其实就是因为虽然函数名变化了，但是，递归的时候用的函数还是之前的函数。所以如果，我们修改<code>factorial</code>就会引发问题了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> num * factorial(num - <span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> copyFactorial = factorial<br><br>factorial = <span class="hljs-function">() =&gt;</span> <span class="hljs-number">0</span><br><span class="hljs-built_in">console</span>.log(copyFactorial(<span class="hljs-number">4</span>))       <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>这时候，我们可以使用<code>arguments.callee</code>来让函数逻辑和函数名解耦。这样子，无论函数叫什么名字，都能够正确的引用正确的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> num * <span class="hljs-built_in">arguments</span>.callee(num - <span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> copyFactorial = factorial<br><br>factorial = <span class="hljs-function">() =&gt;</span> <span class="hljs-number">0</span><br><span class="hljs-built_in">console</span>.log(copyFactorial(<span class="hljs-number">4</span>))       <span class="hljs-comment">// 24</span><br></code></pre></td></tr></table></figure><h2 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h2><p>函数对象会有一个属性<code>caller</code>，这个属性的值是<strong>调用当前函数的函数</strong>，如果是在全局作用域调用的话，则是<code>null</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(outer.caller)<br>    inner()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> inner.caller)<br>    <span class="hljs-built_in">console</span>.log(inner.caller)<br>&#125;<br><br>outer()<br></code></pre></td></tr></table></figure><h2 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h2><p><code>new.target</code>属性用于检测函数是否是使用<code>new</code>关键字调用。如果是使用<code>new</code>关键字调用的，则<code>new.target</code>就是被调用的构造函数；如果是作为普通函数调用，那么<code>new.target</code>的值就是<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;clz&#x27;</span><br>    <span class="hljs-built_in">this</span>.age = <span class="hljs-number">21</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span>.target)<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person()<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span>.target)<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br>sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>那么，这个属性有什么用呢？<br>我们的构造函数通过<code>new</code>关键字可以实例化一个新对象，也可以直接作为普通函数调用，虽然会有构造函数需要首字母为大写的不成文规定，但是开发时还是有可能会搞错的。(虽然类的话，我都是直接用的ES6的<code>class</code>了)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.target) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;这是构造函数!!!&#x27;</span><br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;clz&#x27;</span><br>    <span class="hljs-built_in">this</span>.age = <span class="hljs-number">21</span><br>&#125;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-built_in">console</span>.log(person)<br><br>person = Person()<br><span class="hljs-built_in">console</span>.log(person)<br></code></pre></td></tr></table></figure><h2 id="赠品：函数的length属性"><a href="#赠品：函数的length属性" class="headerlink" title="赠品：函数的length属性"></a>赠品：函数的<code>length</code>属性</h2><p>函数的<code>length</code>属性指该函数期望传入的参数数量，即形参的个数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123; &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params">a</span>) </span>&#123; &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn3</span>(<span class="hljs-params">a, b</span>) </span>&#123; &#125;<br><br><span class="hljs-built_in">console</span>.log(fn1.length)     <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">console</span>.log(fn2.length)     <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(fn3.length)     <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params">a, b, c = <span class="hljs-number">2</span>, d</span>) </span>&#123; &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params">a, b, ...c</span>) </span>&#123; &#125;<br><br><span class="hljs-built_in">console</span>.log(fn1.length)     <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.log(fn2.length)     <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>这是怎么回事呢？<br>我们再重新看下它的定义：函数的<code>length</code>属性指该函数期望传入的参数数量，即形参的个数。</p><p>所以说，形参的数量是不包括剩余参数个数，只包括第一个具有默认值之前的参数个数。</p><p>因为剩余参数和默认值参数都是可传可不传的。至于默认值参数后面的非默认值参数<code>d</code>，应该算是被默认值参数连累了。不过，因为非默认值参数不会有顺序问题，即<code>d</code>不需要依赖<code>a</code>、<code>b</code>、<code>c</code>的值，所以只需要把它的定义往前移即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params">a, b, d, c = <span class="hljs-number">2</span></span>) </span>&#123; &#125;<br></code></pre></td></tr></table></figure><p>这样子，<code>fn1.length</code>就会变成3。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript之函数-二-函数内部三个不常见的属性&quot;&gt;&lt;a href=&quot;#JavaScript之函数-二-函数内部三个不常见的属性&quot; class=&quot;headerlink&quot; title=&quot;JavaScript之函数(二) 函数内部三个不常见的属性&quot;&gt;&lt;/a&gt;J</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之函数(一)</title>
    <link href="https://www.clzczh.top/2022/04/30/js-%E5%87%BD%E6%95%B0%E4%B8%80/"/>
    <id>https://www.clzczh.top/2022/04/30/js-%E5%87%BD%E6%95%B0%E4%B8%80/</id>
    <published>2022-04-30T09:19:33.000Z</published>
    <updated>2022-04-30T09:20:11.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript之函数-一"><a href="#JavaScript之函数-一" class="headerlink" title="JavaScript之函数(一)"></a>JavaScript之函数(一)</h1><blockquote><p>看红宝书+查资料，重新梳理JavaScript的知识。</p></blockquote><h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><p>在ES6之前，我们想要实现默认参数的话，需要先检测某个参数是否等于<code>undefined</code>，如果是的话，证明此时并没有传这个参数，那就给它一个默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    name = <span class="hljs-keyword">typeof</span> name === <span class="hljs-string">&#x27;undefined&#x27;</span> ? <span class="hljs-string">&#x27;clz&#x27;</span> : name<br>    <span class="hljs-keyword">return</span> name<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(mytest(<span class="hljs-string">&#x27;赤蓝紫&#x27;</span>))   <span class="hljs-comment">// 赤蓝紫</span><br><span class="hljs-built_in">console</span>.log(mytest())       <span class="hljs-comment">// clz</span><br></code></pre></td></tr></table></figure><p>但是,ES6之后，就不需要这么麻烦了，ES6支持显示定义默认参数，只需要在函数定义的参数后面使用<code>=</code>就可以给参数设置一个默认值。另外，给参数传<code> undefined</code>相当于没有传值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">name = <span class="hljs-string">&#x27;clz&#x27;</span>, age = <span class="hljs-number">21</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>的年龄是<span class="hljs-subst">$&#123;age&#125;</span>`</span><br>&#125;<br><br><br><span class="hljs-built_in">console</span>.log(mytest())   <span class="hljs-comment">// clz的年龄是21</span><br><span class="hljs-built_in">console</span>.log(mytest(<span class="hljs-string">&#x27;赤蓝紫&#x27;</span>))   <span class="hljs-comment">// 赤蓝紫的年龄是21</span><br><span class="hljs-built_in">console</span>.log(mytest(<span class="hljs-literal">undefined</span>, <span class="hljs-number">999</span>))   <span class="hljs-comment">// clz的年龄是999</span><br></code></pre></td></tr></table></figure><p>使用默认参数时，参数的默认值不会影响到<code>arguments</code>对象，只会影响函数的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">name = <span class="hljs-string">&#x27;clz&#x27;</span>, age = <span class="hljs-number">21</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(name, age)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]&#125;</span>`</span><br>&#125;<br><br><br><span class="hljs-built_in">console</span>.log(mytest())<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;%c%s&#x27;</span>, <span class="hljs-string">&#x27;color: red;font-size:24px;&#x27;</span>, <span class="hljs-string">&#x27;===========================&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(mytest(<span class="hljs-string">&#x27;赤蓝紫&#x27;</span>))<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;%c%s&#x27;</span>, <span class="hljs-string">&#x27;color: red;font-size:24px;&#x27;</span>, <span class="hljs-string">&#x27;===========================&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(mytest(<span class="hljs-literal">undefined</span>, <span class="hljs-number">999</span>))   <br></code></pre></td></tr></table></figure><p>默认参数不仅可以是原始值、对象，还可能是JS表达式，如调用函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">name = <span class="hljs-string">&#x27;clz&#x27;</span>, age = sum(<span class="hljs-number">10</span>, <span class="hljs-number">11</span>)</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;age&#125;</span>`</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(mytest())<br></code></pre></td></tr></table></figure><h3 id="默认参数作用域与暂时性死区"><a href="#默认参数作用域与暂时性死区" class="headerlink" title="默认参数作用域与暂时性死区"></a>默认参数作用域与暂时性死区</h3><p>给多个参数定义默认值跟使用<code>let</code>声明一样，所以后面定义默认值的参数能使用前面定义的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">name = <span class="hljs-string">&#x27;clz&#x27;</span>, nickname = name</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(name, nickname)<br>&#125;<br><br><br>mytest()        <span class="hljs-comment">// clz clz</span><br></code></pre></td></tr></table></figure><p>既然和<code>let</code>声明一样，那么就也会遵循<strong>暂时性死区</strong>，在前面定义的参数不能使用后面定义的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">name = nickname, nickname = <span class="hljs-string">&#x27;clz&#x27;</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(name, nickname)<br>&#125;<br><br><br>mytest()        <br><br><span class="hljs-comment">// ReferenceError: Cannot access &#x27;nickname&#x27; before initialization</span><br></code></pre></td></tr></table></figure><p><strong>参数也有自己的作用域。不能使用函数体定义的变量</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">name = nickname</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> nickname = <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;<br><br><br>mytest()<br><span class="hljs-comment">// nickname is not defined</span><br></code></pre></td></tr></table></figure><p>为什么说参数拥有自己的作用域，而不是参数和函数体属于同一个作用域，只是因为参数使用了后面才定义的变量呢？</p><p>这个和我们上面说的<strong>暂时性死区</strong>就拖不开关系了。如果参数和函数体是同一个作用域，在预编译阶段，执行上下文就会认识函数体的变量了。所以报错消息不会是<code>nickname is not defined</code>，而应该是<code>Cannot access &#39;nickname&#39; before initialization</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> name = nickname<br>    <span class="hljs-keyword">let</span> nickname = <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;<br><br><br>mytest()<br><br><span class="hljs-comment">// Cannot access &#x27;nickname&#x27; before initialization</span><br></code></pre></td></tr></table></figure><p>但是，如果默认参数没有使用的机会的话，即参数有值，那么就不会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">name = nickname</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> nickname = <span class="hljs-string">&#x27;clz&#x27;</span><br><br>    <span class="hljs-keyword">return</span> name<br>&#125;<br><br><br><span class="hljs-built_in">console</span>.log(mytest(<span class="hljs-string">&#x27;czh&#x27;</span>))      <span class="hljs-comment">// czh</span><br><span class="hljs-built_in">console</span>.log(mytest())       <span class="hljs-comment">// nickname is not defined</span><br></code></pre></td></tr></table></figure><h3 id="扩展参数"><a href="#扩展参数" class="headerlink" title="扩展参数"></a>扩展参数</h3><p>首先，先来看一下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mymax</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>[i] &gt; result) &#123;<br>            result = <span class="hljs-built_in">arguments</span>[i]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><br><span class="hljs-built_in">console</span>.log(mymax(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))      <span class="hljs-comment">// 4</span><br><span class="hljs-built_in">console</span>.log(mymax(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>))   <span class="hljs-comment">// 4</span><br><span class="hljs-built_in">console</span>.log(mymax(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">88</span>, <span class="hljs-number">9</span>))  <span class="hljs-comment">// 88</span><br></code></pre></td></tr></table></figure><p>上面的函数可以接收不限定个数的参数，并得到最大值。</p><p>那么，假如给你一个数组，让你调用上面的方法找出数组中的最大值呢？</p><p>在ES6之前呢，我们可以使用<code>apply</code>方法来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">88</span>, <span class="hljs-number">9</span>]<br><span class="hljs-built_in">console</span>.log(mymax.apply(<span class="hljs-literal">null</span>, nums))<br></code></pre></td></tr></table></figure><p>但是，在ES6中，我们可以通过扩展操作符<code>...</code>更方便地实现。对可迭代对象使用扩展操作符，可以将它作为一个参数传入，然后由扩展运算符将可迭代对象拆分，并将迭代返回的每个值单独传入。所以说，函数并不会知道扩展操作符的存在，只是会干好老本行(正常的按照调用函数时传入的参数接收每一个值)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">88</span>, <span class="hljs-number">9</span>]<br><span class="hljs-built_in">console</span>.log(mymax(...nums)) <span class="hljs-comment">// 88</span><br></code></pre></td></tr></table></figure><p>使用扩展操作符传参时，并不会妨碍在前面或后面再传其他的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">88</span>, <span class="hljs-number">9</span>]<br><span class="hljs-built_in">console</span>.log(mymax(...nums)) <span class="hljs-comment">// 88</span><br><span class="hljs-built_in">console</span>.log(mymax(<span class="hljs-number">99</span>, ...nums)) <span class="hljs-comment">// 99</span><br><span class="hljs-built_in">console</span>.log(mymax(...nums, <span class="hljs-number">111</span>)) <span class="hljs-comment">// 111</span><br></code></pre></td></tr></table></figure><p>上面的例子中，扩展操作符和<code>arguments</code>一起使用，但这并不意味着使用扩展通识符需要配合<code>arguments</code>才能使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSum</span>(<span class="hljs-params">a, b, c = <span class="hljs-number">100</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + c<br>&#125;<br><br><br><span class="hljs-built_in">console</span>.log(getSum(...[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]))      <span class="hljs-comment">// 102</span><br><span class="hljs-built_in">console</span>.log(getSum(...[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]))       <span class="hljs-comment">// 4</span><br><span class="hljs-built_in">console</span>.log(getSum(...[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">99</span>]))   <span class="hljs-comment">// 4</span><br><br><br><br><span class="hljs-keyword">let</span> myset = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>])<br><br><span class="hljs-built_in">console</span>.log(myset)  <span class="hljs-comment">// Set(3) &#123; 1, 2, 3 &#125;</span><br><span class="hljs-built_in">console</span>.log([...myset]) <span class="hljs-comment">// [ 1, 2, 3 ]</span><br></code></pre></td></tr></table></figure><h3 id="剩余参数-收集参数"><a href="#剩余参数-收集参数" class="headerlink" title="剩余参数(收集参数)"></a>剩余参数(收集参数)</h3><p>在上面，我们使用扩展操作符可以将一个可迭代对象展开，但是呢？如果扩展操作符用在函数的参数中，还可以手机参数，把参数组合成数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mytest = <span class="hljs-function">(<span class="hljs-params">...nums</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(nums)<br>    <span class="hljs-keyword">return</span> nums.reverse()<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(mytest(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-built_in">console</span>.log(mytest(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>))<br></code></pre></td></tr></table></figure><p>如果剩余参数的前面还有命名参数，那么就只会收集其余的参数。因为剩余参数的结果可变，所以只能把剩余参数作为最后一个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mytest = <span class="hljs-function">(<span class="hljs-params">msg, ...nums</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(msg)<br>    <span class="hljs-built_in">console</span>.log(nums)<br>&#125;<br><br>mytest(<span class="hljs-string">&#x27;消息&#x27;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>)<br></code></pre></td></tr></table></figure><p><strong>剩余参数不会影响到<code>arguments</code>对象，仍然反映调用时传给函数的参数，另外箭头函数不支持<code>arguments</code>对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">msg, ...nums</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(msg)<br>    <span class="hljs-built_in">console</span>.log(nums)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>.length)<br>&#125;<br><br><br>mytest(<span class="hljs-string">&#x27;消息&#x27;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>)<br></code></pre></td></tr></table></figure><h3 id="函数作为值"><a href="#函数作为值" class="headerlink" title="函数作为值"></a>函数作为值</h3><p>可以将函数作为参数传给另一个函数，还可以在一个函数中返回另一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callSomeFn</span>(<span class="hljs-params">fn, arg</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> fn(arg)<br>&#125;<br><br><span class="hljs-keyword">const</span> result = callSomeFn(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num ** <span class="hljs-number">2</span>, <span class="hljs-number">9</span>)<br><span class="hljs-built_in">console</span>.log(result)     <span class="hljs-comment">// 81</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFn</span>(<span class="hljs-params">propertyName</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj1, obj2</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> obj1[propertyName] - obj2[propertyName]<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">const</span> person1 = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">62</span><br>&#125;<br><br><span class="hljs-keyword">const</span> person2 = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;czh&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">21</span><br>&#125;<br><br><span class="hljs-keyword">const</span> ageDifference = createFn(<span class="hljs-string">&#x27;age&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(ageDifference(person1, person2))    <span class="hljs-comment">// 41</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript之函数-一&quot;&gt;&lt;a href=&quot;#JavaScript之函数-一&quot; class=&quot;headerlink&quot; title=&quot;JavaScript之函数(一)&quot;&gt;&lt;/a&gt;JavaScript之函数(一)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;看红宝</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之生成器</title>
    <link href="https://www.clzczh.top/2022/04/30/js-%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://www.clzczh.top/2022/04/30/js-%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2022-04-30T09:18:03.000Z</published>
    <updated>2022-05-18T13:03:39.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript之生成器"><a href="#JavaScript之生成器" class="headerlink" title="JavaScript之生成器"></a>JavaScript之生成器</h1><blockquote><p>看红宝书+查资料，重新梳理JavaScript的知识。</p></blockquote><p>生成器是一个函数的形式，通过在函数名称前加一个星号(<code>*</code>)就表示它是一个生成器。所以<strong>只要是可以定义函数的地方，就可以定义生成器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123; &#125;<br><br><span class="hljs-keyword">const</span> gFn = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123; &#125;<br><br><span class="hljs-keyword">const</span> o = &#123;<br>    * <span class="hljs-function"><span class="hljs-title">gFn</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>箭头函数不能用来定义生成器函数</strong>，因为生成器函数使用**<code> function*</code>语法**编写。</p><p>那为啥上面的第三个例子可以不使用<code> function*</code>语法呢？</p><p>因为那个是简写版本。等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> o = &#123;<br>    <span class="hljs-attr">gFn</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="生成器的简单使用"><a href="#生成器的简单使用" class="headerlink" title="生成器的简单使用"></a>生成器的简单使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>)<br>&#125;<br><br>gFn()<br></code></pre></td></tr></table></figure><p>然后，我们会很”开心”地发现控制台没有打印任何信息。</p><p>这是因为调用生成器函数会产生一个生成器对象，但是这个<strong>生成器一开始处于暂停执行的状态，需要调用<code> next</code>方法才能让生成器开始或恢复执行。</strong></p><p><strong><code> return</code>会直接让生成器到达<code> done: true</code>状态</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">222</span><br>&#125;<br><br><span class="hljs-keyword">const</span> g = gFn()<br><span class="hljs-built_in">console</span>.log(g)<br><br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/clzczh/picgo/raw/master/images/202205182103034.png" alt="image-20220416114721721"></p><p>有种迭代器的既视感。实际上，<strong>生成器实现了Iterable接口</strong>，它们默认的迭代器是自引用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">222</span><br>&#125;<br><br><span class="hljs-keyword">const</span> g = gFn()<br><br><span class="hljs-built_in">console</span>.log(gFn()[<span class="hljs-built_in">Symbol</span>.iterator]())   <span class="hljs-comment">// gFn &#123;&lt;suspended&gt;&#125;</span><br><span class="hljs-built_in">console</span>.log(g === g[<span class="hljs-built_in">Symbol</span>.iterator]()) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>也就是说，<strong>生成器其实就是一个特殊的迭代器</strong></p><h2 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h2><p>提到生成器，自然不能忘记<code> yield</code>关键字。<code> yield</code>能让生成器停止，此时<strong>函数作用域的状态会被保留</strong>，只能通过在生成器对象上调用<code> next</code>方法来恢复执行。</p><p>上面我们已经说了，**<code> return</code>会直接让生成器到达<code> done: true</code>状态<strong>，而</strong><code> yield</code>则是让生成器到达<code> done: false</code>状态，并停止**</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">111</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">222</span><br>&#125;<br><br><span class="hljs-keyword">const</span> g = gFn()<br><br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51670b15ec7843c2a71907169d99732f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220416162345189"></p><p>简单分析一下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4690e87666443d6bd55d7e5a68cccc8~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220416163137033"></p><p>另外，**<code> yield</code>关键字只能在生成器内部使用，用在其他地方会抛出错误。**</p><h2 id="生成器拥有迭代器的特性"><a href="#生成器拥有迭代器的特性" class="headerlink" title="生成器拥有迭代器的特性"></a>生成器拥有迭代器的特性</h2><p>正如上面所说，生成器是特殊的迭代器，所以生成器也拥有迭代器的特性。</p><h3 id="生成器对象之间互不干扰"><a href="#生成器对象之间互不干扰" class="headerlink" title="生成器对象之间互不干扰"></a>生成器对象之间互不干扰</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;red&#x27;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;blue&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;purple&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> g1 = gFn()<br><span class="hljs-keyword">const</span> g2 = gFn()<br><br><span class="hljs-built_in">console</span>.log(g1.next())<br><span class="hljs-built_in">console</span>.log(g2.next())<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42dfb5b7ba6f4d4a862f849db050fedc~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220416164330795"></p><h3 id="生成器对象可作为可迭代对象"><a href="#生成器对象可作为可迭代对象" class="headerlink" title="生成器对象可作为可迭代对象"></a>生成器对象可作为可迭代对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;red&#x27;</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;blue&#x27;</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;purple&#x27;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;white&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> g = gFn()<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i <span class="hljs-keyword">of</span> g) &#123;<br>  <span class="hljs-built_in">console</span>.log(i)    <span class="hljs-comment">// 依次输出red、blue、purple</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code> return</code>的内容不能被迭代。</strong></p><h3 id="完成但并不完成"><a href="#完成但并不完成" class="headerlink" title="完成但并不完成"></a>完成但并不完成</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;red&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;blue&#x27;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;purple&#x27;</span>;<br>&#125;<br><br><br><span class="hljs-keyword">let</span> g = gFn()<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e0eb27fc18b40a0989a4b5fb7484041~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220416165321695"></p><p><code> return</code>会让当前这一次的<code> next</code>调用得到<code> value: return的数据, done: true</code>的结果，此时生成器已经完成了，但是还能继续调用<code> next</code>方法，只是返回的结果都会是<code> &#123;value: undefined, done: true&#125;</code>，即使后面还有<code> yield</code>关键字或<code> return</code>关键字。</p><h2 id="使用yield实现输入和输出"><a href="#使用yield实现输入和输出" class="headerlink" title="使用yield实现输入和输出"></a>使用yield实现输入和输出</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params">initial</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(initial)<br>&#125;<br><br><span class="hljs-keyword">const</span> g = gFn(<span class="hljs-string">&#x27;red&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(g.next())<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60fc092a07804f48afed7ac06fdad615~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220416231233648"></p><h3 id="yield关键字作为函数的中间参数使用"><a href="#yield关键字作为函数的中间参数使用" class="headerlink" title="yield关键字作为函数的中间参数使用"></a>yield关键字作为函数的中间参数使用</h3><p>首先，生成器肯定是能够传参的，因为生成器是一个特殊的函数。只不过它不是一调用就执行的，它需要通过调用生成器对象的<code> next</code>方法才能开始执行。</p><p>那么，如果<code> next</code>方法传参应该怎么接收参数呢？</p><p><code> yield</code>关键字会接收传给<code> next</code>方法的第一个值。</p><p>直接来实践比较好理解。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params">initial</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(initial)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">yield</span>)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">yield</span>)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">yield</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> g = gFn(<span class="hljs-string">&#x27;red&#x27;</span>)<br>g.next(<span class="hljs-string">&#x27;white&#x27;</span>)<br>g.next(<span class="hljs-string">&#x27;blue&#x27;</span>)<br>g.next(<span class="hljs-string">&#x27;purple&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ec69ea4cf8843aca8eca14bce035cd0~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220416232423112"></p><ol><li>生成生成器，此时处于暂停执行的状态</li><li>调用<code> next</code>，让生成器开始执行，输出<code> red</code>，然后准备输出<code> yield</code>，发现是<code> yield</code>，暂停执行，出去外面一下。</li><li>外面给<code> next</code>方法传参<code> blue</code>，又恢复执行，然后之前暂停的地方(即<code> yield</code>)就会接收到<code> blue</code>。然后又遇到<code> yield</code>暂停。</li><li>又恢复执行，输出<code> purple</code></li></ol><p>然后，可能就会有人问，第一次传的<code> white</code>怎么消失了?</p><p>它确实消失了，因为第一次调用<code> next</code>方法是为了开始执行生成器函数，而刚开始执行生成器函数时并没有<code> yield</code>接收参数，所以第一次调用<code> next</code>的值并不会被使用。</p><h3 id="yield关键字同时用于输入和输出"><a href="#yield关键字同时用于输入和输出" class="headerlink" title="yield关键字同时用于输入和输出"></a>yield关键字同时用于输入和输出</h3><p><code> yield</code>可以和<code> return</code>同时使用，同时用于输入和输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">111</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">yield</span> <span class="hljs-number">222</span><br>&#125;<br><br><span class="hljs-keyword">const</span> g = gFn()<br><br><span class="hljs-built_in">console</span>.log(g.next(<span class="hljs-number">333</span>))<br><span class="hljs-built_in">console</span>.log(g.next(<span class="hljs-number">444</span>))<br><span class="hljs-built_in">console</span>.log(g.next(<span class="hljs-number">555</span>))<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/clzczh/picgo/raw/master/images/202205182103615.png" alt="image-20220417091733574"></p><ol><li>生成生成器，此时处于暂停执行的状态</li><li>调用<code> next</code>，让生成器开始执行，遇到<code> yield</code>，暂停执行，因为<code> yield</code>后面还有111，所以带着111作为输出出去外面。</li><li>调用<code> next</code>，生成器恢复执行，遇到<code> return</code>，准备带着后面的数据跑路，结果发现后面是<code> yield</code>，所以又带着222，作为输出到外面。</li><li>调用<code> next</code>，又又又恢复执行，不过这个时候<code>return</code>的内容是<code> yield</code>表达式，所以<code> yield</code>会作为输入接收<code> 555</code>，然后再把它带到外面去输出。</li></ol><p> **<code> yield</code>表达式需要计算要产生的值，如果后面没有值，那就默认是<code> undefined</code>**。<code> return yield x</code>的语法就是，遇到<code> yield</code>，先计算出要产生的值<code> 111</code>，在暂停执行的时候作为输出带出去，然后调用<code> next</code>方法时，<code> yield</code>又作为输入接收<code> next</code>方法的第一个参数。</p><h2 id="产生可迭代对象"><a href="#产生可迭代对象" class="headerlink" title="产生可迭代对象"></a>产生可迭代对象</h2><p>上面已经提过了，生成器是一个特殊的迭代器，那么它能怎样产生可迭代对象呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) &#123;<br>    <span class="hljs-keyword">yield</span> x<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> g = gFn()<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> g) &#123;<br>  <span class="hljs-built_in">console</span>.log(x)    <span class="hljs-comment">// 1、2、3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，利用<code> yield</code>能让生成器暂停执行的特性。</p><p>但是呢？我们还可以使用<code> *</code>来加强<code> yield</code>的行为，让它能迭代一个可迭代对象，从而一次产生一个值。这样子就能让我们能更简单的产生可迭代对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span>* [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;<br><br><span class="hljs-keyword">const</span> g = gFn()<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> g) &#123;<br>  <span class="hljs-built_in">console</span>.log(x)    <span class="hljs-comment">// 1、2、3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么能不能不用<code> *</code>呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;<br><br><span class="hljs-keyword">const</span> g = gFn()<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> g) &#123;<br>  <span class="hljs-built_in">console</span>.log(x)    <span class="hljs-comment">// [1, 2, 3]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不用<code> *</code>的话，就会变成只有一个数组的迭代对象。</p><p>下面再来尝试一下<code> *</code>的用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">innerGFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">111</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">222</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">333</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">outerGFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;iter value: &#x27;</span>, <span class="hljs-keyword">yield</span>* innerGFn())<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> outerGFn()) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;value: &#x27;</span>, x)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25a6fcf628504df8b1eff5c0acfdefd8~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220417094830971"></p><ol><li>上面有两个生成器函数，首先需要拿到<code> outerGFn</code>生成器产生的可迭代对象去迭代。</li><li>然后发现<code> outerGFn</code>也需要拿到<code> innerGFn</code>产生的可迭代对象，去迭代，再产生一个给最外面迭代的可迭代对象</li><li>所以最外面的迭代结果会是<code> 111</code>，<code> 222</code>，而<code> outerGFn</code>的输出则是<code> innerGFn</code>返回的值</li></ol><h3 id="利用-yield-实现递归算法"><a href="#利用-yield-实现递归算法" class="headerlink" title="利用 yield*实现递归算法"></a>利用<code> yield*</code>实现递归算法</h3><p>利用<code> yield*</code>可以实现递归操作，此时生成器可以产生自己。</p><p>话不多说，开干</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">nTimes</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// debugger</span><br>        <span class="hljs-keyword">yield</span>* nTimes(n - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">yield</span> n - <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> nTimes(<span class="hljs-number">5</span>)) &#123;<br>    <span class="hljs-built_in">console</span>.log(x)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca9f42326d48480aabc48dbd1f2cca79~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220417100611148"></p><ol><li>首先，需要迭代<code>nTimes(5)</code>产生的可迭代对象</li><li>进入到<code> nTimes</code>里，又需要一直<code> yield* nTimes(n-1)</code>，一直递归自己，到n===0为止</li><li>n===0，不满足条件不再继续递归，回退到上一层，此时n==1，执行<code> yield n - 1</code></li><li>依次回退到上一层，执行<code> yield n - 1</code>，最终<code> nTimes(5)</code>产生的可迭代对象内的值就是<code>0, 1, 2, 3 ,4</code></li></ol><h2 id="提前终止生成器"><a href="#提前终止生成器" class="headerlink" title="提前终止生成器"></a>提前终止生成器</h2><p>生成器也能和迭代器一样提前终止，不过和迭代器的不太一样。</p><p>可以通过<code>return</code>和<code> throw</code>两种方法，提前终止生成器，都会强制生成器进入关闭状态(<code>generatorFn &#123;&lt;closed&gt;&#125;</code>)。</p><p><strong>一旦进入关闭状态，之后再调用next()都会显示<code> done: true</code>状态。</strong></p><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">111</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">222</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">333</span><br>&#125;<br><br><span class="hljs-keyword">const</span> g = gFn()<br><br><span class="hljs-built_in">console</span>.log(g.next())<br><br><span class="hljs-built_in">console</span>.log(g.return(<span class="hljs-number">99</span>))<br><br><span class="hljs-built_in">console</span>.log(g)<br><br><span class="hljs-built_in">console</span>.log(g.next(<span class="hljs-number">11</span>))<br><span class="hljs-built_in">console</span>.log(g.next(<span class="hljs-number">22</span>))<br><span class="hljs-built_in">console</span>.log(g.return(<span class="hljs-number">88</span>))<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2f36b7b93654ff4a51bac86cfd616dd~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220417102018496"></p><p>当我们调用生成器的<code> return</code>方法时，生成器会进入关闭状态，后续再调用<code> next</code>方法，都会显示<code> done: true</code>状态，且<code> value</code>也只有在再次调用<code> return</code>的时候才能得到不是<code> undefined</code>的值。</p><p><code>for-of循环</code>会忽略状态为<code> done: true</code>的，即如果提前终止生成器，那么实际上就相当于退出<code> for-of循环</code>了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">111</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">222</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">333</span><br>&#125;<br><br><span class="hljs-keyword">const</span> g = gFn()<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> g) &#123;<br>  <span class="hljs-built_in">console</span>.log(x)<br><br>  <span class="hljs-keyword">if</span> (x === <span class="hljs-number">222</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(g.return(<span class="hljs-number">444</span>))<br>    <span class="hljs-built_in">console</span>.log(g)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57960e1b45264bad9eefcc28075a25a4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220417103100765"></p><h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p><code>throw</code>也可以提前终止生成器，且会抛出异常，需要捕获处理抛出的异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">111</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">222</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">333</span><br>&#125;<br><br><span class="hljs-keyword">const</span> g = gFn()<br><span class="hljs-comment">// g.throw(444)       // 如果异常没有被处理的话，会直接报错</span><br><br><span class="hljs-keyword">try</span> &#123;<br>  g.throw(<span class="hljs-number">444</span>)<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-built_in">console</span>.log(e)<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(g)<br><br><span class="hljs-built_in">console</span>.log(g.next())<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/clzczh/picgo/raw/master/images/202205182103877.png" alt="image-20220417103544691"></p><p>不过，如果处理异常是在生成器内部的话，情况就不太一样了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">yield</span> x<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-built_in">console</span>.log(e)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> g = gFn()<br><br><span class="hljs-built_in">console</span>.log(g.next())<br><br>g.throw(<span class="hljs-number">444</span>)<br><span class="hljs-built_in">console</span>.log(g)<br><br><span class="hljs-built_in">console</span>.log(g.next())<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d62235b420442bab99c4ec11026878f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220417104645347"></p><blockquote><p>如果是在生成器内部处理这个错误，那么生成器不会关闭，还可以恢复执行，只是会跳过对应的yield，即会跳过一个值。</p></blockquote><p><strong>throw语句会得到被跳过的那个值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(g.throw(<span class="hljs-number">444</span>))<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/880f12f0b6774089900d29a2e5f79658~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220417104806188"></p><p>以下是个人看法(有错请指出)，处理异常在生成器内部的话，还是会正常终止生成器的，只是在生成器内部的循环中处理异常才会不终止外部的生成器。原因不晓得。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-built_in">console</span>.log(e)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> g = gFn()<br><br><span class="hljs-built_in">console</span>.log(g.next())<br><br><span class="hljs-built_in">console</span>.log(g.throw(<span class="hljs-number">444</span>))<br><span class="hljs-built_in">console</span>.log(g)<br><br><span class="hljs-built_in">console</span>.log(g.next())<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11bcdf0fdc3841b798321a3fabd13a15~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220417105316091"></p><p>参考资料：</p><ul><li>红宝书</li><li>MDN</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript之生成器&quot;&gt;&lt;a href=&quot;#JavaScript之生成器&quot; class=&quot;headerlink&quot; title=&quot;JavaScript之生成器&quot;&gt;&lt;/a&gt;JavaScript之生成器&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;看红宝书+查资料，</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之迭代器</title>
    <link href="https://www.clzczh.top/2022/04/30/js-%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://www.clzczh.top/2022/04/30/js-%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2022-04-30T09:17:03.000Z</published>
    <updated>2022-04-30T09:18:59.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript之迭代器"><a href="#JavaScript之迭代器" class="headerlink" title="JavaScript之迭代器"></a>JavaScript之迭代器</h1><blockquote><p>看红宝书+查资料，重新梳理JavaScript的知识。</p></blockquote><p>迭代就是指可以从一个<strong>数据集</strong>中按照一定的顺序，不断取出数据的过程。</p><p>那么迭代和遍历有啥子区别呢？</p><ul><li>迭代强调依次取数据的过程，不保证把所有的数据都取完</li><li>遍历强调的是要把所有的数据依次全部取出</li></ul><p>在JavaScript中，迭代器是能调用<code> next</code>方法实现迭代的一个对象，该方法返回一个具有两个属性的对象。</p><ul><li><code> value</code>：可迭代对象的下一个值</li><li><code> done</code>：表示是否已经取出所有的数据了。<code> false</code>表示还有数据，<code> true</code>表示后面已经没有数据了。</li></ul><h2 id="迭代器简单使用"><a href="#迭代器简单使用" class="headerlink" title="迭代器简单使用"></a>迭代器简单使用</h2><p>通过可迭代对象中的迭代器工厂函数<code> Symbol.iterator</code>来生成迭代器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = []<br><span class="hljs-built_in">console</span>.log(arr)<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c25ad4ea4934f80a1806fda55debaa4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220415105242128"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-keyword">const</span> iter1 = arr[<span class="hljs-built_in">Symbol</span>.iterator]()   <span class="hljs-comment">// 通过迭代器工厂函数` Symbol.iterator`来生成迭代器。</span><br><span class="hljs-built_in">console</span>.log(iter1)<br><br><span class="hljs-built_in">console</span>.log(iter1.next())<br><span class="hljs-built_in">console</span>.log(iter1.next())<br><span class="hljs-built_in">console</span>.log(iter1.next())<br><span class="hljs-built_in">console</span>.log(iter1.next())<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;%c%s&#x27;</span>, <span class="hljs-string">&#x27;color:red;font-size:24px;&#x27;</span>, <span class="hljs-string">&#x27;================&#x27;</span>)<br><br><span class="hljs-keyword">const</span> mymap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>mymap.set(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;clz&#x27;</span>)<br>mymap.set(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">21</span>)<br><br><span class="hljs-keyword">const</span> iter2 = mymap[<span class="hljs-built_in">Symbol</span>.iterator]()   <span class="hljs-comment">// 通过迭代器工厂函数` Symbol.iterator`来生成迭代器。</span><br><span class="hljs-built_in">console</span>.log(iter2)<br><br><span class="hljs-built_in">console</span>.log(iter2.next())<br><span class="hljs-built_in">console</span>.log(iter2.next())<br><span class="hljs-built_in">console</span>.log(iter2.next())<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29351431e05e4ede895a78638730b234~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220415102139605"></p><p>可以发现，迭代器<strong>是取完</strong>最后一个值之后，即迭代器下一个值<code> value</code>为<code> undefined</code>时，完成。</p><p>但是，上面的说法并不是很准确，并不是迭代器下一个值<code> value</code>为<code> undefined</code>时，就完成的。还需要判断是不是真的没有值，还是是可迭代对象里就有一个值为<code> undefined</code>。如果是可迭代对象里有一个值为<code> undefined</code>的情况，那么此时还是不会变成完成状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-literal">undefined</span>]<br><br><span class="hljs-keyword">const</span> iter1 = arr[<span class="hljs-built_in">Symbol</span>.iterator]()   <span class="hljs-comment">// 通过迭代器工厂函数` Symbol.iterator`来生成迭代器。</span><br><span class="hljs-built_in">console</span>.log(iter1)<br><br><span class="hljs-built_in">console</span>.log(iter1.next())<br><span class="hljs-built_in">console</span>.log(iter1.next())<br><span class="hljs-built_in">console</span>.log(iter1.next())<br><span class="hljs-built_in">console</span>.log(iter1.next())<br><span class="hljs-built_in">console</span>.log(iter1.next())<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0a30494dc164ead83746dc7830d6d23~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220415102828917"></p><h2 id="不同迭代器之间互不干扰"><a href="#不同迭代器之间互不干扰" class="headerlink" title="不同迭代器之间互不干扰"></a>不同迭代器之间互不干扰</h2><p>可以多次调用迭代器工厂函数来生成多个迭代器，每个迭代器都表示对可迭代对象的一次性有序遍历。<strong>不同迭代器之间互不干扰，只会独立地遍历可迭代对象</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-keyword">const</span> iter1 = arr[<span class="hljs-built_in">Symbol</span>.iterator]()   <span class="hljs-comment">// 通过迭代器工厂函数` Symbol.iterator`来生成迭代器。</span><br><span class="hljs-keyword">const</span> iter2 = arr[<span class="hljs-built_in">Symbol</span>.iterator]()<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;迭代器1:&#x27;</span>, iter1.next())<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;迭代器2:&#x27;</span>, iter2.next())<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;迭代器1:&#x27;</span>, iter1.next())<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;迭代器2:&#x27;</span>, iter2.next())<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/537304dd849446a0975f51b513f09a21~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220415110326267"></p><h2 id="迭代器对象可作为可迭代对象"><a href="#迭代器对象可作为可迭代对象" class="headerlink" title="迭代器对象可作为可迭代对象"></a>迭代器对象可作为可迭代对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">const</span> iter = arr[<span class="hljs-built_in">Symbol</span>.iterator]()<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i <span class="hljs-keyword">of</span> iter) &#123;<br>    <span class="hljs-built_in">console</span>.log(i)    <span class="hljs-comment">// 依次输出1、2、3</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="迭代器”与时俱进”"><a href="#迭代器”与时俱进”" class="headerlink" title="迭代器”与时俱进”"></a>迭代器”与时俱进”</h2><p>如果可迭代对象在迭代期间被修改了，迭代器得到的结果也会是修改后的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-built_in">console</span>.log(arr)<br><br><span class="hljs-keyword">const</span> iter = arr[<span class="hljs-built_in">Symbol</span>.iterator]()<br><span class="hljs-built_in">console</span>.log(iter.next())<br><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">999</span><br><br><span class="hljs-built_in">console</span>.log(iter.next())<br><span class="hljs-built_in">console</span>.log(iter.next())<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/clzczh/picgo/raw/master/images/202204301717568.png" alt="image-20220415110751803"></p><h2 id="完成但并不完成"><a href="#完成但并不完成" class="headerlink" title="完成但并不完成"></a>完成但并不完成</h2><p>当我们迭代到<code> done: true</code>之后，再调用<code>next</code>是不是会报错，或者不返回任何内容呢？</p><p>然而，并不是，迭代器会处于一种<strong>完成但并不完成</strong>的状态，<code> done: true</code>表示已经完成了，但是后续还能一直调用<code> next</code>，虽然得到的结果一直都会是<code> &#123; value: undefined, done: true &#125;</code>。这就是为什么说<strong>完成但并不完成</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-keyword">const</span> iter = arr[<span class="hljs-built_in">Symbol</span>.iterator]()<br><br><span class="hljs-built_in">console</span>.log(iter.next())<br><span class="hljs-built_in">console</span>.log(iter.next())<br><span class="hljs-built_in">console</span>.log(iter.next())<br><span class="hljs-built_in">console</span>.log(iter.next())<br><span class="hljs-built_in">console</span>.log(iter.next())<br><span class="hljs-built_in">console</span>.log(iter.next())<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e2c749e3b62439eac910f99280a8fb1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220415120158682"></p><h2 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h2><p>从上面的例子中，我们就可以知道是通过<strong>通过迭代器工厂函数<code> Symbol.iterator</code>来生成迭代器</strong>，所以我们需要实现一个迭代器迭代器工厂函数，然后迭代器可以调用<code> next</code>方法，所以还需要实现一个<code> next</code>方法，至于迭代器工厂函数，实际上直接返回实例<code> this</code>。</p><p>计数器例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">limit</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.count = <span class="hljs-number">1</span><br>    <span class="hljs-built_in">this</span>.limit = limit<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.count &lt;= <span class="hljs-built_in">this</span>.limit) &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">value</span>: <span class="hljs-built_in">this</span>.count++<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span> &#125;<br>    &#125;<br>  &#125;<br>  [<span class="hljs-built_in">Symbol</span>.iterator]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> Counter(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">const</span> iter = counter[<span class="hljs-built_in">Symbol</span>.iterator]()<br><br><span class="hljs-built_in">console</span>.log(iter.next())<br><span class="hljs-built_in">console</span>.log(iter.next())<br><span class="hljs-built_in">console</span>.log(iter.next())<br><span class="hljs-built_in">console</span>.log(iter.next())<br><span class="hljs-built_in">console</span>.log(iter.next())<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1167066e0dae4ef1a03802bde864f9b9~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220416105256374"></p><p>乍一看，没啥问题，但是如果我们使用<code> for-of</code>来遍历就能发现问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> Counter(<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> counter) &#123;<br>  <span class="hljs-built_in">console</span>.log(i)<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;另一轮迭代：&#x27;</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> counter) &#123;<br>  <span class="hljs-built_in">console</span>.log(i)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6949ce37821f4dc29b825ed2b8789828~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220416105416835"></p><p>使用<code> for-of</code>循环也变成一次性的了。这是因为<code> count</code>是该实例的变量，所以两次迭代都是使用的那一个变量，但是该变量第一次循环完之后，就已经超过限制了，所以再次使用<code> for-of</code>循环就得不到任何的结果了。</p><p>可以把<code> count</code>变量放在闭包里，然后通过闭包返回迭代器，这样子每创建一个迭代器都会对应一个新的计数器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">limit</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.limit = limit<br>    &#125;<br>    <br>    [<span class="hljs-built_in">Symbol</span>.iterator]() &#123;<br><br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">const</span> limit = <span class="hljs-built_in">this</span>.limit<br><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-comment">// 迭代器工厂函数必须要要返回一个带有next方法的对象，因为迭代实际就是通过调用next方法来实现的</span><br>            <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;<br>                <span class="hljs-keyword">if</span> (count &lt;= limit) &#123;<br>                    <span class="hljs-keyword">return</span> &#123;<br>                        <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>,<br>                        <span class="hljs-attr">value</span>: count++<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span> &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> Counter(<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> counter) &#123;<br>    <span class="hljs-built_in">console</span>.log(i)<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;另一轮迭代：&#x27;</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> counter) &#123;<br>    <span class="hljs-built_in">console</span>.log(i)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbb72f540e014e499c7b12d5145554d1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220416110540741"></p><h2 id="提前终止迭代器"><a href="#提前终止迭代器" class="headerlink" title="提前终止迭代器"></a>提前终止迭代器</h2><p>就和使用<code> for-of</code>循环一样，迭代器会很聪明地去调用<code> next</code>方法，当迭代器提前终止时，它也会去调用<code> return</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-built_in">Symbol</span>.iterator]() &#123;<br><br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">const</span> limit = <span class="hljs-built_in">this</span>.limit<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-comment">// 迭代器工厂函数必须要要返回一个带有next方法的对象，因为迭代实际就是通过调用next方法来实现的</span><br>        <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">if</span> (count &lt;= limit) &#123;<br>                <span class="hljs-keyword">return</span> &#123;<br>                    <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>,<br>                    <span class="hljs-attr">value</span>: count++<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span> &#125;<br>            &#125;<br><br>        &#125;,<br><br>        <span class="hljs-keyword">return</span>() &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;提前终止迭代器&#x27;</span>)<br>            <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> Counter(<span class="hljs-number">5</span>)<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> counter) &#123;<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(i)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/clzczh/picgo/raw/master/images/202204301717226.png" alt="image-20220416111320222"></p><p><strong>如果迭代器没有关闭，就可以继续从上次离开的地方继续迭代</strong>。数组地迭代器就是不能关闭的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">const</span> iter = arr[<span class="hljs-built_in">Symbol</span>.iterator]()<br><br>iter.return = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;提前退出迭代器&#x27;</span>)<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i <span class="hljs-keyword">of</span> iter) &#123;<br>    <span class="hljs-built_in">console</span>.log(i)<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i <span class="hljs-keyword">of</span> iter) &#123;<br>    <span class="hljs-built_in">console</span>.log(i)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abf4f2cef97d44659f1ed767baa74e70~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220416112206220"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript之迭代器&quot;&gt;&lt;a href=&quot;#JavaScript之迭代器&quot; class=&quot;headerlink&quot; title=&quot;JavaScript之迭代器&quot;&gt;&lt;/a&gt;JavaScript之迭代器&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;看红宝书+查资料，</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Array.from的食用指南</title>
    <link href="https://www.clzczh.top/2022/04/17/Array-from%E7%9A%84%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://www.clzczh.top/2022/04/17/Array-from%E7%9A%84%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2022-04-17T04:07:41.000Z</published>
    <updated>2022-04-23T05:00:00.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Array-from的食用指南"><a href="#Array-from的食用指南" class="headerlink" title="Array.from的食用指南"></a>Array.from的食用指南</h1><h2 id="将伪数组转换成数组"><a href="#将伪数组转换成数组" class="headerlink" title="将伪数组转换成数组"></a>将伪数组转换成数组</h2><p>伪数组：有若干索引属性的任意对象以及一个length属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fakeArr = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>  <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;purple&#x27;</span>,<br>  <span class="hljs-attr">w</span>: <span class="hljs-string">&#x27;white&#x27;</span>,<br>  <span class="hljs-attr">length</span>: <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(fakeArr))  <span class="hljs-comment">// [&#x27;red&#x27;, undefined, &#x27;purple&#x27;, undefined]</span><br></code></pre></td></tr></table></figure><p>伪数组的属性名应该是索引，所以上面的例子中，属性名是字母的都得不到结果，因为没有该索引位置上的属性，所以最终的结果是<code> undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fakeArr = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>  <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;purple&#x27;</span>,<br>  <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;white&#x27;</span>,<br>  <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;black&#x27;</span>,<br>  <span class="hljs-attr">length</span>: <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(fakeArr))  <span class="hljs-comment">//  [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;purple&#x27;, &#x27;white&#x27;]</span><br></code></pre></td></tr></table></figure><p>其次，如果如果伪数组的属性有很多(个数比<code> length</code>属性还要多)的话，就会直截取一段<code> length</code>长度的。如上面例子中，<code> fakeArr</code>对象中实际有5个属性(除掉<code> length</code>)，但是最终通过<code> Array.from</code>转换成的真数组的长度为4。</p><h2 id="将字符串转换成数组"><a href="#将字符串转换成数组" class="headerlink" title="将字符串转换成数组"></a>将字符串转换成数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mystr = <span class="hljs-string">&#x27;Hello, CLZ!&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(mystr))  <span class="hljs-comment">// [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;,&#x27;, &#x27; &#x27;, &#x27;C&#x27;, &#x27;L&#x27;, &#x27;Z&#x27;, &#x27;!&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="将可迭代对象转换成数组"><a href="#将可迭代对象转换成数组" class="headerlink" title="将可迭代对象转换成数组"></a>将可迭代对象转换成数组</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mymap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>mymap.set(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;clz&#x27;</span>)<br>mymap.set(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">21</span>)<br><br><span class="hljs-built_in">console</span>.log(mymap)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(mymap))<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/9hDvzS8WJjnMNTR.png" alt="image-20220415004308593"></p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myset = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()<br><br>myset.add(<span class="hljs-number">1</span>)<br>myset.add(<span class="hljs-number">2</span>)<br>myset.add(<span class="hljs-number">1</span>)<br>myset.add(<span class="hljs-number">3</span>)<br><br><span class="hljs-built_in">console</span>.log(myset)              <span class="hljs-comment">// Set(3) &#123;1, 2, 3&#125;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(myset))  <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><h2 id="配合Set使用实现数组去重"><a href="#配合Set使用实现数组去重" class="headerlink" title="配合Set使用实现数组去重"></a>配合Set使用实现数组去重</h2><p>首先，利用的是<code> Set</code>结构不允许重复的特性，然后利用<code> Array.from</code>可以将<strong>可迭代对象</strong>转换成数组，而<code> Set</code>恰恰也是可迭代对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr))<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(unique([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>]))  <span class="hljs-comment">// [1, 2, 3, 6, 7, 5]</span><br></code></pre></td></tr></table></figure><h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><p>因为数组也是可迭代对象，所以也可以将数组转换成数组，而这就实现了克隆</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowClone</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(arr)<br>&#125;<br><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">const</span> arrCopy = shallowClone(arr)<br><br><span class="hljs-built_in">console</span>.log(arr)<br><span class="hljs-built_in">console</span>.log(arrCopy)<br><br>arrCopy[<span class="hljs-number">2</span>] = <span class="hljs-number">999</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;%c%s&#x27;</span>, <span class="hljs-string">&#x27;color: red;font-size: 24px;&#x27;</span>, <span class="hljs-string">&#x27;=====================&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(arr)<br><span class="hljs-built_in">console</span>.log(arrCopy)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/ab9NOnq6uotfwT2.png" alt="image-20220415092319749"></p><p>另外，<code>Array.from</code>是浅克隆，即如果数组里面有对象，那么只是复制对象的引用而已。所以修改克隆的对象，也会修改到原来的对象。直接给对象赋新值倒是不会修改到原来的对象因为这个时候是直接把地址给修改了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowClone</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(arr)<br>&#125;<br><br><span class="hljs-keyword">const</span> arr2 = [<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">21</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;czh&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">1</span><br>  &#125;<br>]<br><br><span class="hljs-keyword">const</span> arrCopy2 = shallowClone(arr2)<br><br>arrCopy2[<span class="hljs-number">1</span>].age = <span class="hljs-number">999</span><br><span class="hljs-built_in">console</span>.log(arr2)<br><span class="hljs-built_in">console</span>.log(arrCopy2)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/jTUzdwHQJZka1lt.png" alt="image-20220415092444023"></p><h2 id="接收第二个映射函数参数"><a href="#接收第二个映射函数参数" class="headerlink" title="接收第二个映射函数参数"></a>接收第二个映射函数参数</h2><p>可以直接修改数组的每一项的值，而不再需要<code> Array.from().map()</code>，因为<code> Array.from().map()</code>会创建出一个中间数组，而这个中间数组你没办法使用，却会占内存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> a2 = <span class="hljs-built_in">Array</span>.from(a1, <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ** <span class="hljs-number">2</span>);<br><span class="hljs-built_in">console</span>.log(a2); <span class="hljs-comment">// [1, 4, 9, 16]</span><br><br><span class="hljs-keyword">const</span> a3 = <span class="hljs-built_in">Array</span>.from(a1).map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ** <span class="hljs-number">2</span>)    <span class="hljs-comment">// 用这个方法来实现的话，会创建一个访问不到的中间数组</span><br><span class="hljs-built_in">console</span>.log(a3)   <span class="hljs-comment">// [1, 4, 9, 16]</span><br></code></pre></td></tr></table></figure><h2 id="接收第三个映射函数参数"><a href="#接收第三个映射函数参数" class="headerlink" title="接收第三个映射函数参数"></a>接收第三个映射函数参数</h2><p>第三个参数可以指定第二个映射函数参数中<code> this</code>的值。这么一说，<code>Array.from</code>既有类似<code> map</code>的功能，还有类似<code> bind</code>的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br><span class="hljs-keyword">const</span> a2 = <span class="hljs-built_in">Array</span>.from(a1, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x * <span class="hljs-built_in">this</span>.value<br>&#125;, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">3</span><br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(a1)   <span class="hljs-comment">//  [1, 2, 3, 4]</span><br><span class="hljs-built_in">console</span>.log(a2)   <span class="hljs-comment">//  [3, 6, 9, 12]</span><br></code></pre></td></tr></table></figure><p>参考链接：</p><ul><li><a href="https://blog.csdn.net/yangaoyuan1999/article/details/119993661">https://blog.csdn.net/yangaoyuan1999/article/details/119993661</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Array-from的食用指南&quot;&gt;&lt;a href=&quot;#Array-from的食用指南&quot; class=&quot;headerlink&quot; title=&quot;Array.from的食用指南&quot;&gt;&lt;/a&gt;Array.from的食用指南&lt;/h1&gt;&lt;h2 id=&quot;将伪数组转换成数组&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript冷门知识</title>
    <link href="https://www.clzczh.top/2022/04/17/JavaScript%E5%86%B7%E9%97%A8%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.clzczh.top/2022/04/17/JavaScript%E5%86%B7%E9%97%A8%E7%9F%A5%E8%AF%86/</id>
    <published>2022-04-17T04:07:00.000Z</published>
    <updated>2022-04-23T04:57:47.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript冷门知识"><a href="#JavaScript冷门知识" class="headerlink" title="JavaScript冷门知识"></a>JavaScript冷门知识</h1><p>看红宝书，重新梳理JavaScript的知识。这部分<strong>主要是梳理冷门的知识点</strong>(对个人来说是冷门的)</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul><li>ECMAScript(核心)：提供核心功能。每门语言的根本，大同小异，会有一些特殊的地方，比如JS有变量提升。</li><li>DOM(文档对象模型)：提供与网页内容交互的方法和接口。主要就是操作DOM元素，包括样式修改、新增节点、删除节点等。</li><li>BOM(浏览器对象模型)：提供与浏览器交互的方法和接口。比如<code> location</code>对象可以获取或设置窗口的URL等。</li></ul><h2 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a>script元素</h2><p>首先，学习过JS的话，都知道<code> script</code>的使用方式有两种。</p><ul><li>直接在<code>script</code>标签内写JS代码</li><li>在另一个文件中写JS代码，再引入</li></ul><p>那么，如果两种方式一起用会怎样呢？</p><p>mytest.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>)<br></code></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/mytest.js&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/alOs8JV4jvNPgZF.png" alt="image-20220413211327017"></p><p>也就是说，如果两者一起使用的话，那么只有外部文件的代码会执行，会忽略行内代码。</p><p>也算可以看出是更推荐外部文件的做法。(个人想法)</p><p>使用外部文件有什么好处呢？</p><ol><li>可维护性。如果使用的是行内代码，且一个html文件中有很多业务逻辑的话，后期维护会很困难，首先找到问题代码都要花点时间。</li><li>缓存。使用外部文件的话，如果两个页面用到同一个文件，该文件只需要下载一次，但是如果是行内代码，则会反复下载</li><li>可复用性。可以把通用的代码抽离成一个文件，实现代码复用，而不需要有大量重复代码。</li></ol><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>首先，script如果没有<code> defer</code>和<code> async</code>，那么浏览器会立即加载并执行脚本，也就是说，会阻塞后面的文档元素的加载和渲染。</p><ul><li><p>有<code> defer</code>属性的话，<strong>会异步加载js文件</strong>，即和加载渲染后续文档元素并行进行。<strong>加载完成后并不一定是立即执行，而是要等到所有元素解析完成后(图片是在之后解析完成)，在<code> DOMContentLoaded</code>事件触发之前完成</strong></p></li><li><p>有<code> async</code>属性的话，<strong>会异步加载js文件</strong>。加载完成会立即执行，阻塞后面的文档元素的加载和渲染。所以不一定按顺序执行，谁先加载完成就谁先执行。</p></li></ul><p><img src="https://s2.loli.net/2022/04/23/KxbBzN6DQjgO5Ua.jpg" alt="异步加载"></p><p>图片来源：<a href="https://www.pianshen.com/article/2104972721/">https://www.pianshen.com/article/2104972721/</a></p><p>由图总结：</p><ul><li><strong><code>defer</code>和<code> async</code>都是异步加载</strong></li><li><strong><code> defer</code>：加载完成后，会等到所有元素都解析完成后才执行。使用<code> defer</code>的<code> js</code>代码会按顺序执行</strong></li><li><strong><code> async</code>：加载完成后，立即执行。使用<code> async</code>的js代码不一定会按顺序执行</strong></li></ul><p>开始案例测试：下面最好在<code> network</code>面板中设置<code> Fast 3G</code>，让效果看得更明显。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://www.clzczh.top/medias/featureimages/17.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 400px&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>456<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-built_in">window</span>.onload = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;load&#x27;</span>)</span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;DomContentLoaded&#x27;</span>)</span><br><span class="javascript">    &#125;)</span><br><span class="javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>什么都没加(在<code> head</code>内，js代码分别是弹出111、222、333)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/mytest1.js&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/mytest2.js&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/mytest3.js&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/ntcbPHReAak7Vsr.gif" alt="js"></p><p>可以发现，任何的元素都没有加载就开始执行js代码了，也就是说js加载会阻塞元素的加载和渲染</p><p>defer属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/mytest1.js&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/mytest2.js&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/mytest3.js&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/n3Q7qyxltKcLJOv.gif" alt="js"></p><p>先加载完所有的元素(不包括图片，图片会在<code> DOMContentLoaded</code>后加载)，然后才执行js代码，执行完js代码后触发<code> DOMContentLoaded</code>事件，然后再加载图片。<strong>使用<code> defer</code>属性的<code> js</code>代码会按顺序执行</strong></p><p>async属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/mytest1.js&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/mytest2.js&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/mytest3.js&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/ItR8WFarXpSckiE.gif" alt="js"></p><p>有点混乱，因为async是异步加载js，而且加载完就会阻塞并执行。<strong>添加<code> async</code>属性的<code> js</code>代码不一定按顺序执行</strong>(多刷新几次)</p><p>所以上面的图中是执行js代码前就执行完<code> DOMContentLoaded</code>事件了，然后在执行js的代码途中，加载出图片</p><p>除了使用<code> async</code>和<code> defer</code>属性来实现异步加载js外，也可以通过动态创建脚本的形式来实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;load&#x27;</span>)<br>&#125;<br><br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;DomContentLoaded&#x27;</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> fragment = <span class="hljs-built_in">document</span>.createDocumentFragment()    <span class="hljs-comment">// 这里使用一个小优化手段：先创建一个文档碎片，把需要新增的内容先添加到文档碎片上，最后才把文档碎片添加到真实DOM上。这样就能够减少操作DOM。</span><br><br><span class="hljs-keyword">const</span> myscript1 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>)<br>myscript1.src = <span class="hljs-string">&#x27;./js/mytest1.js&#x27;</span><br>fragment.appendChild(myscript1)<br><br><span class="hljs-keyword">const</span> myscript2 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>)<br>myscript2.src = <span class="hljs-string">&#x27;./js/mytest2.js&#x27;</span><br>fragment.appendChild(myscript2)<br><br><span class="hljs-keyword">const</span> myscript3 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>)<br>myscript3.src = <span class="hljs-string">&#x27;./js/mytest3.js&#x27;</span><br>fragment.appendChild(myscript3)<br><br><span class="hljs-built_in">document</span>.head.appendChild(fragment)<br></code></pre></td></tr></table></figure><p>效果就相当于添加了<code> async</code>属性。</p><p>最后再来一下结论：</p><ul><li><strong><code>defer</code>和<code> async</code>都是异步加载</strong></li><li><strong><code> defer</code>：加载完成后，会等到所有元素都解析完成后才执行。使用<code> defer</code>的<code> js</code>代码会按顺序执行</strong></li><li><strong><code> async</code>：加载完成后，立即执行。使用<code> async</code>的js代码不一定会按顺序执行</strong></li></ul><h2 id="标签退出循环"><a href="#标签退出循环" class="headerlink" title="标签退出循环"></a>标签退出循环</h2><p>说到退出循环的方法，常用的就是<code> break</code>和<code> continue</code>。<code> break</code>是退出整个循环，而<code> continute</code>是跳过当前那一个循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 输出0、1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">break</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(i)<br>&#125;<br><br><span class="hljs-comment">// 输出0、1、3、4</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">continue</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>那么嵌套循环，需要跳出两层的循环怎么办呢？</p><p>很明显，使用<code> break</code>只能跳出一层，而使用<code> continute</code>能跳出一层的一轮。</p><p>这个时候就到我们的标签退出循环法闪亮登场了。</p><p>其实用的也是<code> break</code>，只是我们使用<code> break</code>一般后面不带东西而已，也就是说没带标签则默认跳一层循环。所以，我们要跳两层循环的话，首先得在要使用的位置添加上标签，然后跳出循环时使用<code> break 标签</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;<br>label:<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span> &amp;&amp; j == <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">break</span> label;<br>    &#125;<br>    num++;<br>  &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(num); <span class="hljs-comment">// 12</span><br></code></pre></td></tr></table></figure><p>结果是12的原因：</p><ul><li>i=0时，执行5次</li><li>i=1时，执行5次</li><li>i=2时，执行2次</li></ul><h2 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h2><p>作用：将代码作用域设置为特定的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>,<br>  <span class="hljs-attr">job</span>: <span class="hljs-string">&#x27;frontEnd&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">with</span> (person) &#123;<br>  <span class="hljs-built_in">console</span>.log(name)<br>  <span class="hljs-built_in">console</span>.log(age)<br>  <span class="hljs-built_in">console</span>.log(job)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对象常量Object-freeze"><a href="#对象常量Object-freeze" class="headerlink" title="对象常量Object.freeze"></a>对象常量<code>Object.freeze</code></h2><p>对象是引用类型，所以即使使用<code> const</code>来定义对象变量，它也是能够改变内容的，只是它的地址没有变化而已。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> o = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;<br><br>o.name = <span class="hljs-string">&#x27;czh&#x27;</span><br><span class="hljs-built_in">console</span>.log(o)    <span class="hljs-comment">// &#123;name: &#x27;czh&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>通过<code> Object.freeze</code>冻结一个对象后，这个对象就不能再被修改，包括添加新属性、删除已有属性、修改属性等。</p><p>所以可以通过<code> Object.freeze</code>来实现对象常量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> o = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;<br><br><span class="hljs-built_in">Object</span>.freeze(o)<br><br>o.name = <span class="hljs-string">&#x27;czh&#x27;</span><br><span class="hljs-built_in">console</span>.log(o)    <span class="hljs-comment">// &#123;name: &#x27;clz&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="函数参数按值传递"><a href="#函数参数按值传递" class="headerlink" title="函数参数按值传递"></a>函数参数按值传递</h2><p>这个一直都是这么听别人说的，但是没有证明过，其他语言倒是有看过证明，现在就来证明一波js版本的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">o</span>) </span>&#123;<br>  o.age = <span class="hljs-number">21</span><br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;<br><br>mytest(person)<br><br><span class="hljs-built_in">console</span>.log(person)  <span class="hljs-comment">// &#123;name: &#x27;clz&#x27;, age: 21&#125;</span><br></code></pre></td></tr></table></figure><p>可以发现，修改函数里的对象<code> o</code>会导致函数外的<code> person</code>也发生变化。</p><p>这是什么原因呢?可能的原因有两个：</p><ol><li>当函数参数是对象时，是按引用传递的</li><li>函数参数是按值传递的，但是对象是引用类型。所以<code> o</code>还是会通过引用访问对象，那么函数内部给<code> o</code>添加<code>age</code>属性时，函数外部的对象也会反映这个变化。因为<code> o</code>指向的对象保存在全局作用域的堆内存中。</li></ol><p>然后，先来说一下按值传递和按引用传递的概念。</p><ul><li>按值传递：<strong>值会被复制到函数内的局部变量</strong>。也就是说，此时<strong>直接给局部变量赋新值是不会修改到函数外的变量的</strong>，但是，如果参数是对象，而且不是直接给局部变量赋新值，而是给它添加新属性，或者修改属性值的话，还是影响到函数外的变量的，因为<strong>对象是引用类型的</strong>。</li><li>按引用传递：<strong>值在内存的位置会被保存到函数内的局部变量中</strong>。也就是说，此时<strong>直接给局部变量赋新值是会修改到函数外的变量的</strong>，因为此时局部变量是地址，也就是说，直接给局部变量赋新值的话，就是将那个地址改变，既然修改的是地址，那么函数外部的变量肯定也会跟着变，因为它指向的地址都被别人改了。</li></ul><p>下面对上面的例子进行修改，来证明对象也是按值传递的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">o</span>) </span>&#123;<br>  o.age = <span class="hljs-number">21</span><br><br>  o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br>  o.age = <span class="hljs-number">999</span><br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;clz&#x27;</span><br>&#125;<br><br>mytest(person)<br><br><span class="hljs-built_in">console</span>.log(person)  <span class="hljs-comment">// &#123;name: &#x27;clz&#x27;, age: 21&#125;</span><br></code></pre></td></tr></table></figure><p>如果<code> person</code>是按引用传递的，那么当我们将<code> o</code>重新定义为一个新对象时，<code> person</code>也应该会自动将指针改成指向<code> age</code>为999的对象。</p><p>但是最后的结果是<code> &#123;name: &#39;clz&#39;, age: 21&#125;</code>，也就是说，函数中参数的值改变之后，原始的引用还是没有改变。即<strong>函数参数按值传递</strong></p><p>参考链接：</p><ul><li><p>JS红宝书</p></li><li><p><a href="https://www.pianshen.com/article/2104972721/">浅谈 defer 和 async 的区别</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript冷门知识&quot;&gt;&lt;a href=&quot;#JavaScript冷门知识&quot; class=&quot;headerlink&quot; title=&quot;JavaScript冷门知识&quot;&gt;&lt;/a&gt;JavaScript冷门知识&lt;/h1&gt;&lt;p&gt;看红宝书，重新梳理JavaScript的知识</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局(二)</title>
    <link href="https://www.clzczh.top/2022/04/17/CSS-layout-2/"/>
    <id>https://www.clzczh.top/2022/04/17/CSS-layout-2/</id>
    <published>2022-04-17T04:05:00.000Z</published>
    <updated>2022-04-23T05:04:14.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS布局-二"><a href="#CSS布局-二" class="headerlink" title="CSS布局(二)"></a>CSS布局(二)</h1><h2 id="等高布局"><a href="#等高布局" class="headerlink" title="等高布局"></a>等高布局</h2><p>等高布局，顾名思义，就是指子元素在父元素中高度相等的布局。</p><p>开始之前，先看一个情境。</p><p>html代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>      《绝园的暴风雨》（绝园のテンペスト）是城平京原作、左有秀构成、彩崎廉作画的日本漫画。<br>      漫画单行本日文版由史克威尔艾尼克斯（SQUARE ENIX）出版发行，繁体中文版分别由中国台湾的尖端出版社和中国香港的玉皇朝代理发行<br>      该作讲述了日本突然开始蔓延着可怕的疾病，主人公泷川吉野等人见证了世界破灭的开始，故事也由此展开。<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>《绝园的暴风雨》（绝园のテンペスト）是城平京原作、左有秀构成、彩崎廉作画的日本漫画。<br>      漫画单行本日文版由史克威尔艾尼克斯（SQUARE ENIX）出版发行，繁体中文版分别由中国台湾的尖端出版社和中国香港的玉皇朝代理发行<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>《绝园的暴风雨》（绝园のテンペスト）是城平京原作、左有秀构成、彩崎廉作画的日本漫画。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br></code></pre></td></tr></table></figure><p>css代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#eee</span>;<br>&#125;<br><br><span class="hljs-selector-tag">main</span>&gt;<span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">vertical-align</span>: top;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: purple;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/EJ6sp1Ctxvl45In.png" alt="image-20220412094720147"></p><p>看着就有点突兀，这时候就需要我们的等高布局登场了。</p><h3 id="padding-bottom正值-margin-bottom负值"><a href="#padding-bottom正值-margin-bottom负值" class="headerlink" title=" padding-bottom正值+ margin-bottom负值"></a><code> padding-bottom</code>正值+<code> margin-bottom</code>负值</h3><ol><li>先给子元素一个非常大的<code> padding-bottom</code></li><li>然后在给子元素添加同样大小的<code> margin-bottom</code>负值</li><li>最后父元素设置<code> overflow: hidden</code>，去掉多余的</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#eee</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br><span class="hljs-selector-tag">main</span>&gt;<span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">vertical-align</span>: top;<br>  <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">9999px</span>;<br>  <span class="hljs-attribute">margin-bottom</span>: -<span class="hljs-number">9999px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/eXQJyxhgYjOb1iE.png" alt="image-20220412102529836"></p><p><strong>原理</strong>：</p><p><img src="https://s2.loli.net/2022/04/23/FKY1Cea5LtWxJQE.png" alt="image-20220412101933083"></p><p>添加<code> padding-bottom</code>后，如上图所示，此时的父元素的高度就是高度最大的子元素的高度，即上面第一个子元素的高度</p><p><img src="https://s2.loli.net/2022/04/23/qtDz6mKGL31MNv7.png" alt="image-20220412102320912"></p><p>再添加<code> margin-bottom</code>，值为<code> padding-bottom</code>的负值，就会让父元素收缩成只有最高的子元素的高度</p><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>因为flex布局，项目默认会拉伸为父元素的高度。当然，想让它不拉伸为父元素的高度也可以，只需要设置父元素<code> align-items</code>来防止拉伸，因为<code> align-items</code>是设置项目在侧轴的排列方式，默认值为<code> stretch</code>，即会拉伸。</p><p>IE9以及IE9以下不支持。(没用过IE，要考虑老版本浏览器(过气浏览器)需要留意一下)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">main &#123;<br>  <span class="hljs-attr">display</span>: flex;<br>  <span class="hljs-comment">/* align-items: flex-start; */</span><span class="hljs-comment">/* 防止拉伸 */</span><br>  <span class="hljs-comment">/* align-items: stretch; */</span><span class="hljs-comment">/* 手动设置拉伸，默认值就是` stretch` */</span><br>  color: #eee;<br>&#125;<br><br>main&gt;div &#123;<br>  <span class="hljs-attr">width</span>: 300px;<br>&#125;<br><br>.left &#123;<br>  background-color: red;<br>&#125;<br><br>.center &#123;<br>  background-color: blue;<br>&#125;<br><br>.right &#123;<br>  background-color: purple;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果子元素高度，且不为<code> auto</code>，那么此时用flex布局就不能实现等高布局</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#eee</span>;<br>&#125;<br><br><span class="hljs-selector-tag">main</span>&gt;<span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>  <span class="hljs-attribute">height</span>: auto;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: purple;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/LjFPafiCcKJG2e4.png" alt="image-20220412223532259"></p><h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><p>实现比较简单，只需要设置父元素的属性<code> grid-auto-flow</code>为<code> column</code>即可，会自动规划好元素如何排列。</p><p>具体原理不太熟悉，暂时没研究出个所以然。(没学过grid布局，有空学一下，方法先写在这先)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-<span class="hljs-attribute">auto</span>-flow: column;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#eee</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>和flex优点像双胞胎的感觉：</p><ul><li><p>IE9以及IE9以下不支持</p></li><li><p><strong>如果子元素高度，且不为<code> auto</code>，那么此时用grid布局也不能实现等高布局</strong></p></li></ul><h3 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h3><p>利用表格中所有单元格高度都相等的特性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">display</span>: table;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#eee</span>;<br>&#125;<br><br><span class="hljs-selector-tag">main</span>&gt;<span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: purple;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="上下固定中间自适应布局"><a href="#上下固定中间自适应布局" class="headerlink" title="上下固定中间自适应布局"></a>上下固定中间自适应布局</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bottom&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="定位法"><a href="#定位法" class="headerlink" title="定位法"></a>定位法</h3><p> 上中下盒子都设置绝对定位。然后先让上盒子的<code> top</code>设置为0，这时候就能实现上盒子固定了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-selector-tag">main</span>&gt;<span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.top</span> &#123;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来让下盒子固定，设置<code> bottom</code>为0</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.bottom</span> &#123;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: purple;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，实现中间自适应，只需要设置<code> top</code>为上盒子的高度，<code> bottom</code>为下盒子的高度即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/MbQqs6roWtjL1za.png" alt="image-20220413090218636"></p><h3 id="flex布局-1"><a href="#flex布局-1" class="headerlink" title="flex布局"></a>flex布局</h3><p>利用<code> flex: 1</code>划分剩余空间的特性，并配合<code> flex-direction: column</code>切换主轴为垂直方向。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>&#125;<br><br><span class="hljs-selector-class">.top</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.bottom</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: purple;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/WhyuaelDKmCQPz9.png" alt="image-20220413091031723"></p><p>结果发现，压根没起到中间自适应的效果。</p><p>分析以下原因：因为<code> main</code>没有设置高度，且它的祖先元素<code> html</code>、<code> body</code>都没有设置高度，所以<code> main</code>的高度就只有被上盒子和下盒子的高度撑开的那部分。既然如此，怎么可能还会有剩余空间呢？</p><p>经过上面的分析，我们发现<code> main</code>的高度只有被上下盒子撑开的部分，所以我们需要依次给<code> html</code>、<code> body</code>、<code> main</code>设置<code> height</code>为<code> 100%</code>，这样子就可能一直继承屏幕的高度。这时候，<code> main</code>的高度就是屏幕高度，而中间占满剩余空间，也就是说中间自适应了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span>,<br><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/i2maeotxpSbP1TY.png" alt="image-20220413091744030"></p><h3 id="grid布局-1"><a href="#grid布局-1" class="headerlink" title="grid布局"></a>grid布局</h3><p>利用<code> grid-template-rows</code>属性设置每一行的高度，中间需要自适应则设置成<code>auto</code></p><p>同理，<code> html</code>、<code> body</code>、<code> main</code>的高度都需要设置成<code> 100%</code>，去继承屏幕的高度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span>,<br><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-rows: <span class="hljs-number">100px</span> auto <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.top</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.bottom</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: purple;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="table布局-1"><a href="#table布局-1" class="headerlink" title="table布局"></a>table布局</h3><p>父盒子<code> main</code>设置<code> table</code>布局，子盒子设置<code> display: table-row</code>按行来分</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span>,<br><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">display</span>: table;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">main</span>&gt;<span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-row;<br>&#125;<br><br><span class="hljs-selector-class">.top</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.bottom</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: purple;<br>&#125;<br></code></pre></td></tr></table></figure><p>搞完了？</p><p>别太天真了</p><p><img src="https://s2.loli.net/2022/04/23/VTdLb7oJgyXlwOf.png" alt="image-20220413094050459"></p><p>看似搞完了，实际没有搞完。</p><p>这是为什么呢？实际上<code> display: table-row</code>就相当于是把<code> main</code>下的<code> div</code>都转换成<code> tr</code>，而<code> tr</code>内是必须要有内容的。</p><p><img src="https://s2.loli.net/2022/04/23/ALuZedkMiaEOnK4.png" alt="image-20220413094745563"></p><h2 id="粘连布局"><a href="#粘连布局" class="headerlink" title="粘连布局"></a>粘连布局</h2><p>粘连布局：</p><ul><li>当主体内容足够多时(即<code> main</code>的高度足够大)，<code> footer</code>紧跟在后面</li><li>当主体内容较少(小于屏幕高度)，<code>footer</code>粘连在屏幕的底部</li></ul><h3 id="footer添加-margin-top负值"><a href="#footer添加-margin-top负值" class="headerlink" title=" footer添加 margin-top负值"></a><code> footer</code>添加<code> margin-top</code>负值</h3><p>html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>主体内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><p>首先，我们需要主体内容较少时，<code> footer</code>粘连在屏幕底部。</p><p>所以主体盒子<code> main</code>的高度应该为屏幕高度，然后给<code> footer</code>设置<code> margin-top</code>为自身高度的负值，让<code> footer</code>上移到屏幕底部。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br><br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">background-color</span>: purple;<br>  <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/YXLuwhljvS2mkpx.png" alt="image-20220413162103731"></p><p>第一步完成，但是第二步还没实现，让我们来看看。</p><p><img src="https://s2.loli.net/2022/04/23/Ic8OHRxXCn62qjN.png" alt="image-20220413162211675"></p><p>为什么？因为我们设置的<code> main</code>盒子的高度为100%，也就是说当内容超过屏幕高度时就会溢出。所以我们不应该给<code> main</code>盒子设置正常的高度，而应该设置最小高度<code> min-height</code>，这样子当高度小时，就会是屏幕高度，而当高度大于屏幕高度时，高度还是正常的内容的高度。</p><p>而且，还应该给<code> main</code>盒子设定<code> padding-bottom</code>的值为<code> footer</code>的高度，这样子就不会出现负<code> margin</code>导致<code> footer</code>覆盖内容。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/1gBw9Txoe6YMyfk.png" alt="image-20220413164724164"></p><p>捡了芝麻丢了西瓜？</p><p>也不算，后面只要在再加一个小步骤就行了。首先呢？上面我们给<code> main</code>盒子设置了<code> min-width: 100%</code>，所以当内容很少时，<code> main</code>盒子的高度会是屏幕的高度，再加上一个<code> padding-bottom</code>，那么就自然不能实现<strong>当主体内容较少(小于屏幕高度)，<code>footer</code>粘连在屏幕的底部</strong></p><p>解决方案就是添加多一个外盒子<code> wrap</code>把<code> min-height: 100%</code>给<code> wrap</code>而不是<code> main</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>主体内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>主体内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#wrap</span> &#123;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/AUJbCzamt3LRysu.png" alt="image-20220413165452965"></p><h3 id="footer以外的部分添加-margin-bottom负值"><a href="#footer以外的部分添加-margin-bottom负值" class="headerlink" title=" footer以外的部分添加 margin-bottom负值"></a><code> footer</code>以外的部分添加<code> margin-bottom</code>负值</h3><p>从上面的例子中，我们可以给<code> footer</code>添加负<code> margin-top</code>值来实现，而添加负<code> margin-top</code>值只是为了让<code> footer</code>能够让<code> footer</code>上移到屏幕底部。所以不给<code> footer</code>添加<code> margin-top</code>负值，给<code> footer</code>外的部分添加<code> margin-bottom</code>负值也能得到同样的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-id">#wrap</span> &#123;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">margin-bottom</span>: -<span class="hljs-number">50px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br><br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">background-color</span>: purple;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="flex布局-2"><a href="#flex布局-2" class="headerlink" title="flex布局"></a>flex布局</h3><p>还是老样子，利用flex布局项目的属性<code> flex</code>会平分剩余空间的特性。</p><p>html</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">div</span> class=&quot;box&quot;&gt;<br>  &lt;<span class="hljs-selector-tag">main</span>&gt;<br>    &lt;<span class="hljs-selector-tag">p</span>&gt;主体内容&lt;/<span class="hljs-selector-tag">p</span>&gt;<br>  &lt;/<span class="hljs-selector-tag">main</span>&gt;<br>  &lt;<span class="hljs-selector-tag">footer</span>&gt;&lt;/<span class="hljs-selector-tag">footer</span>&gt;<br>&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><p>css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br><br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">background-color</span>: purple;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="grid布局-2"><a href="#grid布局-2" class="headerlink" title="grid布局"></a>grid布局</h3><p>有flex布局的地方怎么能没有grid布局(×?)。flex布局可以通过子项目的属性<code> flex</code>来设置平分剩余空间，只有一个属性没有设置宽(<code> flex-direction: row</code>)或高(<code> flex-direction: column</code>)的时候，就是占满剩余空间。而通过<code> grid-template-rows</code>可以设置每一行的高度，为<code> auto</code>时是自动计算，为<code> 1fr</code>时是占满剩余空间</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>, <br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-rows: <span class="hljs-number">1</span>fr <span class="hljs-number">50px</span>;<br>  <span class="hljs-comment">/* grid-template-rows: auto 50px; */</span><br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>&#125;<br><br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: purple;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>最后提一嘴：flex布局、grid布局真nb</strong></p><p>参考链接：</p><ul><li><a href="https://juejin.cn/post/6844903615182667789">常用的多列等高布局收藏</a></li><li><a href="https://www.jianshu.com/p/30bc9751e3e8">css实现上下固定中间自适应布局</a></li><li><a href="https://blog.csdn.net/weixin_39854011/article/details/115487389">实现粘连布局</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS布局-二&quot;&gt;&lt;a href=&quot;#CSS布局-二&quot; class=&quot;headerlink&quot; title=&quot;CSS布局(二)&quot;&gt;&lt;/a&gt;CSS布局(二)&lt;/h1&gt;&lt;h2 id=&quot;等高布局&quot;&gt;&lt;a href=&quot;#等高布局&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="布局" scheme="https://www.clzczh.top/tags/%E5%B8%83%E5%B1%80/"/>
    
    <category term="CSS" scheme="https://www.clzczh.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局(一)</title>
    <link href="https://www.clzczh.top/2022/04/17/CSS-layout-1/"/>
    <id>https://www.clzczh.top/2022/04/17/CSS-layout-1/</id>
    <published>2022-04-17T04:04:05.000Z</published>
    <updated>2022-04-23T05:05:25.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS布局-一"><a href="#CSS布局-一" class="headerlink" title="CSS布局(一)"></a>CSS布局(一)</h1><blockquote><p>看面试题，看到两个没听说过的布局<strong>圣杯布局</strong>、<strong>双飞翼布局</strong>。这就来学习一波CSS布局。</p></blockquote><h2 id="单列布局"><a href="#单列布局" class="headerlink" title="单列布局"></a>单列布局</h2><p>只需要让<code>header</code>，<code>footer</code>充满整个屏幕，<code>header</code>的内容区、<code>foooter</code>的内容区，<code>content</code>设置一样的宽度，然后都设置<code> margin: 0 auto</code>实现居中即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">  <span class="hljs-selector-tag">html</span>,</span><br><span class="css">  <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="css">  &#125;</span><br><span class="css"></span><br><span class="css">  <span class="hljs-selector-tag">header</span>,</span><br><span class="css">  <span class="hljs-selector-tag">footer</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;</span><br><span class="css">  &#125;</span><br><span class="css"></span><br><span class="css">  <span class="hljs-selector-tag">nav</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">1000px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="css">  &#125;</span><br><span class="css"></span><br><span class="css">  <span class="hljs-selector-class">.content</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">1000px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: skyblue;</span><br><span class="css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="css">  &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/xLR9YnwUEOztapB.png" alt="image-20220410085540497"></p><p>实际上，可以单独抽离出用于显示内容(包括header、footer的内容部分)，也称为<strong>版心</strong>，然后给对应的内容添加该类名即可。</p><p>如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.w</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">1000px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;w&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content w&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果不需要<code> header</code>、<code> footer</code>铺满整个屏幕，那么只需要将<code> header</code>、<code> footer</code>的宽设置为主内容的宽度，并居中即可 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">header</span>,<br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">1000px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有版心CSS，则直接给<code> header</code>、<code> footer</code>也添加对应类名就行。</p><h2 id="双栏布局"><a href="#双栏布局" class="headerlink" title="双栏布局"></a>双栏布局</h2><p>双栏布局是一种非常使用的布局。左边是目录、公告等内容，右边是主内容。</p><p>双栏布局的侧边栏部分通常都是放目录、公告等需要稳定表现的内容，所以侧边栏需要固定，然后让主内容自适应。</p><h3 id="float-margin-overflow"><a href="#float-margin-overflow" class="headerlink" title="float+margin/overflow"></a>float+margin/overflow</h3><p>原理就是侧边栏给定宽度，并设置<code> float</code>为<code> left</code>或<code> right</code>，然后主内容部分设置<code> margin-left</code>或<code> margin-right</code>为侧边栏的宽即可,或者设置<code> overflow</code>为<code>hidden</code>(通过<code> overflow</code>触发<code> BFC</code>，而<code> BFC</code>不会重叠浮动元素)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">  <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;</span><br><span class="css">  &#125;</span><br><span class="css"></span><br><span class="css">  <span class="hljs-selector-class">.sidebar</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="css">  &#125;</span><br><span class="css"></span><br><span class="css">  <span class="hljs-selector-class">.content</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">    <span class="hljs-comment">/* 或 */</span></span><br><span class="css">    <span class="hljs-comment">/* overflow: hidden; */</span></span><br><span class="css">    <span class="hljs-attribute">background-color</span>: skyblue;</span><br><span class="css">  &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sidebar&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>赤蓝紫<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>赤蓝紫<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>赤蓝紫<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/elFp71UuMnWYZom.png" alt="image-20220410093542181"></p><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>利用flex布局的flex属性会均分剩余部分的特性，给侧边栏设置宽度，然后给主内容设置<code> flex: 1;</code>即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;<br>&#125;<br><br><span class="hljs-selector-class">.sidebar</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br><br><span class="hljs-selector-class">.content</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/9xuqj5DTRnf4d2P.png" alt="image-20220410093438013"></p><h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><p>设置为grid布局的话，只需要设置<code> grid-template-columns</code>为<code> auto 1fr</code>即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: auto <span class="hljs-number">1</span>fr;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>没学过grid布局，这就来研究下<code>auto 1fr</code>是个啥子玩意。</p><p>首先，当然就是设置为像素值看下什么情况。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">300px</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/CQew3ZgnUMN4hxm.png" alt="image-20220412220011426"></p><p>从上图可以发现，第一个值其实就是第一列的宽度，而第二个值就是第二列的宽度。</p><p>既然如此，那么设置成<code> auto 1fr</code>后就能实现就好理解了。首先第一列设置为<code> auto</code>，即会根据子元素宽度来设置，而子元素的宽度已经设置为<code> 200px</code>了，所以第一列就是<code> 200px</code>，而第二列的<code> 1fr</code>则是占满剩余空间。(没学过grid，推测的结果，不对请指正)</p><h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><p>两边的侧边栏固定宽度，中间的主内容自适应宽度。</p><p>比较有名的有圣杯布局、双飞翼布局两种。</p><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><p>圣杯布局是比较特殊的三栏布局。它需要主内容部分优先渲染，即在<code> DOM</code>结构中，应该先有主内容，再有侧边栏</p><p>DOM结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><p>先来一下基础设置，方便观察</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>,<br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">main</span>&gt;<span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.middle</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: brown;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/tqsTAkR7SzwIXbj.png" alt="image-20220410112051855"></p></li><li><p>设置三部分都为左浮动，并且设置主内容的宽度为100%，实现中间内容自适应</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span>&gt;<span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.middle</span> &#123;<br>  <span class="hljs-comment">/* 实现主内容自适应 */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/sVB2GZ5qbEhQLC7.png" alt="image-20220410112455988"></p></li><li><p>最外面的大盒子添加<code> padding</code>，为两边的侧边栏留出位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">main &#123;<br>  <span class="hljs-attr">padding</span>: <span class="hljs-number">0</span> 300px <span class="hljs-number">0</span> 200px;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/ZGJsu5pNRO7QqwV.png" alt="image-20220410113023844"></p></li><li><p>实现左盒子放到留出的位置上</p><ol><li><p>首先，为左盒子添加<code> margin-left: -100%</code>，让它去到上一层</p><p><img src="https://s2.loli.net/2022/04/23/yxW2lhcR3nsLEfa.png" alt="image-20220410113325917"></p></li><li><p>然后，设置<code> position</code>为<code> relative</code>，即相对定位，然后设置<code> left</code>为盒子的宽度的负值，让它去到该去的位置</p><p><img src="https://s2.loli.net/2022/04/23/4H9T12mY5bigXBS.png" alt="image-20220410113605454"></p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">.left &#123;<br>  <span class="hljs-attr">position</span>: relative;<br>  left: -200px;<br>  width: 200px;<br>  background-color: skyblue;<br>  margin-left: -<span class="hljs-number">100</span>%;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>右盒子也是一样的道理，不过右盒子设置的<code> margin-left</code>不再是<code> 100%</code>了，而是自身宽度的负值，因为它们都是浮动的，那么右盒子想要上去，就只需要往左移自己的宽度就行了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: brown;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">300px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/eBGqkaCYIcHtJF5.png" alt="image-20220410114527931"></p></li></ol><p><strong>这里用到了浮动，所以还需要清除浮动</strong>。之前有些过清除浮动的文章，有需要可以看一下</p><p>添加页头、页脚</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">header</span>,<br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#666</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/4epsSoabc2Lq79B.png" alt="image-20220410121450757"></p><p>发现，没有页脚，而这正是浮动导致的。所以需要清除浮动。(清除浮动的方法可参考之前的文章)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span>:after &#123;<br>  content: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/PlHgbqxhAMN4Ini.png" alt="image-20220410121554288"></p><h4 id="CSS完整代码"><a href="#CSS完整代码" class="headerlink" title="CSS完整代码"></a>CSS完整代码</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>,<br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">main</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">300px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br><span class="hljs-selector-tag">main</span>&gt;<span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.middle</span> &#123;<br>  <span class="hljs-comment">/* 实现主内容自适应 */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: skyblue;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: brown;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span>,<br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#666</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><p>双飞翼布局是圣杯布局的改进版。因为当屏幕很小时，圣杯布局就会乱掉，双飞翼布局就是改进了这一点。</p><p><img src="https://s2.loli.net/2022/04/23/FpkHbUOi2KEfcCN.png" alt="image-20220410123134247"></p><p>改变的点：</p><ul><li>不再是通过<code> main</code>的<code> padding</code>给左右盒子留位置，而是通过给<code> 新增子盒子</code>添加<code> margin</code>值</li><li>左右盒子不再需要相对定位</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 多了个子盒子 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middleInner&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><p>css样式改动(其中<code> main</code>的样式直接删除，不包括伪元素、子元素)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.middleInner</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-comment">/* 换成通过子盒子的margin值给左右盒子留位置 */</span><br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">300px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: brown;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/4ZIFD9Me2mp6PYs.png" alt="image-20220410124532101"></p><p>因为不是通过父盒子<code> main</code>的<code> padding</code>留位置，所以直接<code> margin</code>负值就能到要去的位置，而不需要再使用相对定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: skyblue;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: brown;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">300px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/JE3hlUwruW6CR4f.png" alt="image-20220410124949728"></p><p><img src="https://s2.loli.net/2022/04/23/1zig4kxrC2dSIwL.png" alt="image-20220410125316766"></p><h4 id="CSS完整代码-1"><a href="#CSS完整代码-1" class="headerlink" title="CSS完整代码"></a>CSS完整代码</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>,<br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.middleInner</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-comment">/* 换成通过子盒子的margin值给左右盒子留位置 */</span><br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">300px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-tag">main</span>:after &#123;<br>  content: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br><br><span class="hljs-selector-tag">main</span>&gt;<span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.middle</span> &#123;<br>  <span class="hljs-comment">/* 实现主内容自适应 */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: skyblue;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: brown;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span>,<br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#666</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考链接：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/37094651">CSS常用布局介绍:单栏双栏,圣杯,双飞翼/附各类居中技巧</a></li><li><a href="https://juejin.cn/post/6844903710070407182">几种常见的CSS布局</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS布局-一&quot;&gt;&lt;a href=&quot;#CSS布局-一&quot; class=&quot;headerlink&quot; title=&quot;CSS布局(一)&quot;&gt;&lt;/a&gt;CSS布局(一)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;看面试题，看到两个没听说过的布局&lt;strong&gt;圣杯布局&lt;/stron</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="布局" scheme="https://www.clzczh.top/tags/%E5%B8%83%E5%B1%80/"/>
    
    <category term="CSS" scheme="https://www.clzczh.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>var、let和const之间的区别</title>
    <link href="https://www.clzczh.top/2022/04/13/js-let-var-const/"/>
    <id>https://www.clzczh.top/2022/04/13/js-let-var-const/</id>
    <published>2022-04-13T04:17:45.000Z</published>
    <updated>2022-04-23T05:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="var、let和const之间的区别"><a href="#var、let和const之间的区别" class="headerlink" title="var、let和const之间的区别"></a>var、let和const之间的区别</h1><h2 id="作用域不同"><a href="#作用域不同" class="headerlink" title="作用域不同"></a>作用域不同</h2><p><strong><code> var</code>是函数作用域，<code> let</code>、<code>const</code>是块级作用域</strong></p><ul><li><p>函数作用域就是在函数中声明了<code> var</code>变量，那么这个变量在整个函数里都是有效的。</p></li><li><p>块级作用域则是在块里是有效的。块级作用域就是用<code>&#123;&#125;</code>包住的区域，常用的有<code>for</code>，<code>while</code>，<code>if</code>等，只是有<code> &#123;&#125;</code>包住也是块级作用域</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">111</span><br>  <span class="hljs-keyword">let</span> b = <span class="hljs-number">222</span><br>  <span class="hljs-keyword">const</span> c = <span class="hljs-number">333</span><br><br>  <span class="hljs-built_in">console</span>.log(a)  <span class="hljs-comment">// 111</span><br>  <span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">// 222</span><br>  <span class="hljs-built_in">console</span>.log(c)<span class="hljs-comment">// 333</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(a)  <span class="hljs-comment">// 111</span><br><span class="hljs-comment">// console.log(b) // b is not defined</span><br><span class="hljs-built_in">console</span>.log(c)  <span class="hljs-comment">// c is not defined</span><br></code></pre></td></tr></table></figure><h2 id="有无变量提升"><a href="#有无变量提升" class="headerlink" title="有无变量提升"></a>有无变量提升</h2><p><strong><code> var</code>有变量提升，<code> let</code>和<code> const</code>没有变量提升</strong></p><p>即<code> let</code>和<code> const</code>不需要先声明，再使用，否则会报错，而<code> var</code>不需要先声明再使用，可以先使用后声明，不会报错，不过赋值的时候，值一直是<code> undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a)    <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(b)    <span class="hljs-comment">// Cannot access &#x27;b&#x27; before initialization</span><br><span class="hljs-comment">// console.log(c)  // Cannot access &#x27;c&#x27; before initialization</span><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">111</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">222</span><br><span class="hljs-comment">// const c = 333</span><br></code></pre></td></tr></table></figure><p>**注意，这里报的错不是<code> b is not defined</code>而是<code> Cannot access &#39;b&#39; before initialization</code>**。也就是说：</p><ul><li>从广义上来说，<code> let</code>和<code> const</code>没有变量提升，因为在声明前使用会报错</li><li>从狭义上来说，<code> let</code>和<code> const</code>是有变量提升的，因为实际上用它们定义的变量已经被执行上下文记住了，否则应该会报错<code> is not defined</code>才对。</li></ul><p><strong><code>let</code>和<code> const</code>究竟有没有变量提升取决于怎么定义变量提升</strong>：</p><ul><li>如果变量提升指的是变量可以在声明前使用，则没有变量提升</li><li>如果变量提升指的是变量在声明前有没有被执行上下文记住的话，则是有变量提升的。</li></ul><h2 id="能否被重新定义"><a href="#能否被重新定义" class="headerlink" title="能否被重新定义"></a>能否被重新定义</h2><p><code>let</code>和<code> const</code>不能被重新声明，但是<code>var</code>可以被重新声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span><br><span class="hljs-built_in">console</span>.log(a)    <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// let b = 1</span><br><span class="hljs-comment">// let b = 2    // Identifier &#x27;b&#x27; has already been declared</span><br><br><span class="hljs-comment">// const c = 1</span><br><span class="hljs-comment">// const c = 2     // Identifier &#x27;b&#x27; has already been declared</span><br></code></pre></td></tr></table></figure><p>在这个例子中，把下面的注释去掉后，就能够再次证明上面说的<code> let</code>、<code>const</code>有没有变量提升是取决于怎么定义的。</p><p><img src="https://s2.loli.net/2022/04/23/n2KgUkhuYe1dEwJ.png" alt="image-20220411210448047"></p><p>因为JavaScript是单线程的，如果预编译执行上下文没有记住用<code> let</code>或<code> const</code>定义的变量的话，按理来说会先输出a，才报错，但是不是，也就是说，实际上执行上下文在预编译的时候，也已经记住用<code> let</code>和<code> const</code>声明的变量了。</p><p><strong>不能在函数内部重新声明参数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">args</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> args<span class="hljs-comment">// 报错</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是，如果是在函数里的另一个块级作用域里则可以重新声明参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">args</span>) </span>&#123;<br>  &#123;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-number">111</span>;<br>    <span class="hljs-built_in">console</span>.log(args)<span class="hljs-comment">// 111</span><br><br>    &#123;<br>      <span class="hljs-keyword">let</span> args = <span class="hljs-number">222</span>;<br>      <span class="hljs-built_in">console</span>.log(args)<span class="hljs-comment">// 222</span><br>    &#125;<br><br>  &#125;<br>&#125;<br><br>mytest(<span class="hljs-number">123</span>)<br></code></pre></td></tr></table></figure><h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><p>块中用<code> let</code>和<code> const</code>声明的变量，在使用<code> let</code>或<code> const</code>声明变量之前，该变量都是不可用的。这在语法上称为<strong>暂时性死区</strong>(temporal dead zone)</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> a = <span class="hljs-number">111</span><br><br>&#123;<br>  console.log(a)    <span class="hljs-comment">// Cannot access &#x27;a&#x27; before initialization</span><br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">222</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子，就是典型的暂时性死区的例子。在上面有全局变量，在下面有块级变量，但是在中间则是谁都没法访问到。</p><h2 id="全局作用域下是否会挂载到window对象"><a href="#全局作用域下是否会挂载到window对象" class="headerlink" title="全局作用域下是否会挂载到window对象"></a>全局作用域下是否会挂载到window对象</h2><p>全局作用域下，使用<code> var</code>声明的变量会被挂载到<code> window</code>对象上，而使用<code> let</code>和<code> const 则不会</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">111</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.a)   <span class="hljs-comment">// 111</span><br><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">222</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.b)   <span class="hljs-comment">// undefined</span><br><br><span class="hljs-keyword">const</span> c = <span class="hljs-number">333</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.c)   <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h2 id="const与let的区别"><a href="#const与let的区别" class="headerlink" title="const与let的区别"></a><code>const</code>与<code>let</code>的区别</h2><p><code> const</code>与<code> var</code>的区别如上。<code> const</code>和<code> let</code>的区别就是<strong>const声明的是常量，声明后不能够修改</strong></p><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(i)    <span class="hljs-comment">// 输出5，5次</span><br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>因为setTimeout是宏任务(JS执行机制可参考之前的文章)，所以执行输出语句时，for循环已经执行完成了，然后用<code> var</code>声明的变量是函数作用域，所以会打印出5个5。可以尝试在for循环外打印<code>i</code>，能得到<code> 5</code>的结果</p><p>把上面的<code> var</code>换成<code> let</code>后，会依次输出0、1、2、3、4</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(i)    <span class="hljs-comment">// 输出0、1、2、3、4</span><br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code> let</code>是块级作用域，用<code> let</code>声明的变量会被绑定到<code> setTimeout</code>上，所以并不会受到外界的影响，输出的结果就会是正常的0、1、2、3、4。</p><p>另外，for循环还有一个特别的地方：<strong>设置循环变量的部分是一个父作用域，而循环体内是一个单独的子作用域</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span>; i++) &#123;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">222</span>       <span class="hljs-comment">// 这里不会报错，因为这里实际上是另一个子作用域</span><br>  <span class="hljs-built_in">console</span>.log(i)    <span class="hljs-comment">// 222</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里顺便再来回顾一下，暂时性死区。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span>; i++) &#123;<br>  <span class="hljs-built_in">console</span>.log(i)<span class="hljs-comment">// Cannot access &#x27;i&#x27; before initialization</span><br>    <br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">222</span>      <br>  <span class="hljs-built_in">console</span>.log(i)   <br>&#125;<br></code></pre></td></tr></table></figure><p>参考链接：</p><ul><li><a href="https://blog.csdn.net/qq_58875046/article/details/123067627">let 到底有无变量提升</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;var、let和const之间的区别&quot;&gt;&lt;a href=&quot;#var、let和const之间的区别&quot; class=&quot;headerlink&quot; title=&quot;var、let和const之间的区别&quot;&gt;&lt;/a&gt;var、let和const之间的区别&lt;/h1&gt;&lt;h2 id=&quot;作</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>一道问题引起的重学预编译</title>
    <link href="https://www.clzczh.top/2022/04/12/js-precompile/"/>
    <id>https://www.clzczh.top/2022/04/12/js-precompile/</id>
    <published>2022-04-12T00:47:43.000Z</published>
    <updated>2022-04-23T05:02:25.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一道问题引起的重学预编译"><a href="#一道问题引起的重学预编译" class="headerlink" title="一道问题引起的重学预编译"></a>一道问题引起的重学预编译</h1><blockquote><p>前言：变量提升与函数提升本来是我个人觉得没必要写笔记来复习的知识。因为这部分看的面试题都能做对，就是说确实学的挺扎实的。直到遇到了下面这道题。</p></blockquote><h2 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h2><p>参加掘金日新计划时，在群里看到的问题(改造了下)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(a)<br>  a = <span class="hljs-number">111</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123; &#125;<br>  a = <span class="hljs-number">222</span><br>  <span class="hljs-built_in">console</span>.log(a)<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(a)<br></code></pre></td></tr></table></figure><h2 id="基础知识回顾"><a href="#基础知识回顾" class="headerlink" title="基础知识回顾"></a>基础知识回顾</h2><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>实际上，变量的提升其实算是JS的诟病了，所以es6出来了<code> let</code>和<code> const</code>之后，都是推荐使用<code> let</code>和<code> const</code>了。</p><p>在执行函数前，会先预编译，把<b style="color: red">用<code> var</code>声明的变量的声明提升到前面</b>。</p><p>首先，假如我们只有一个语句<code> console.log(a)</code>，这样子会直接报错<code> a is not defined</code>。</p><p>如果只声明变量，但是不赋值，则会得到<code> undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a;<br><span class="hljs-built_in">console</span>.log(a)<br></code></pre></td></tr></table></figure><p>那么，如果先打印<code> a</code>，之后再定义<code> a</code>呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a)<br><span class="hljs-keyword">var</span> a<br></code></pre></td></tr></table></figure><p>首先呢？JS是单线程的，所以JS理论上是从上到下执行代码的，所以按理来说会报错<code> a is not defined</code>。</p><p>但是，实际上在执行代码前，会先进行一次预编译，把<code> var变量</code>的声明提升到前面。</p><p>所以上面的代码实际上也相当于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a<br><span class="hljs-built_in">console</span>.log(a)<br></code></pre></td></tr></table></figure><p><b style="color: red">变量提升只会把变量的声明提升到前面，赋值则不会提升到前面。</b></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a)<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span><br><span class="hljs-built_in">console</span>.log(a)<br></code></pre></td></tr></table></figure><p>会先输出<code> undefined</code>，然后输出<code> 123</code></p><p>预编译后的代码如下，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a<br><span class="hljs-built_in">console</span>.log(a)<br>a = <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p><b style="color: red">函数声明整体提升，函数调用不提升</b></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(mytest)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>)<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(mytest)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">333</span>)<br><br>mytest()<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">444</span>)<br></code></pre></td></tr></table></figure><p>预编译后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>)<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(test)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>)<br><br><span class="hljs-built_in">console</span>.log(mytest)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">333</span>)<br><br>mytest()<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">444</span>)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/23/DJL2lFnNQvuPCez.png" alt="image-20220407234205587"></p><p>使用<strong>使用变量声明函数</strong>，则走的是变量提升路线，而不是函数声明路线</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(mytest)   <span class="hljs-comment">// undefined</span><br>mytest()    <span class="hljs-comment">// mytest is not a function</span><br><br><span class="hljs-keyword">var</span> mytest = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>函数内部也会有变量提升，这时候会先预处理全局的，再预处理函数的，且函数内的变量、函数提升不能提升到函数外。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a)    <span class="hljs-comment">// undefined</span><br>  b()   <span class="hljs-comment">// 456</span><br><br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">456</span>)<br>  &#125;<br>&#125;<br><br>mytest1()<br><span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">//  a is not defined</span><br></code></pre></td></tr></table></figure><p>预编译后的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">456</span>)<br>    &#125;<br>    <span class="hljs-keyword">var</span> a<br>    <br>    <span class="hljs-built_in">console</span>.log(a)<br>    b()<br>    <br>    a = <span class="hljs-number">123</span><br>&#125;<br><br>mytest1()<br><span class="hljs-built_in">console</span>.log(a)<br></code></pre></td></tr></table></figure><p><strong>如果函数内部的变量没有定义，直接赋值，则会直接变成全局变量</strong>(应该算是遗留bug，<strong>不要这样用</strong>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  b()   <span class="hljs-comment">// 456</span><br><br>  a = <span class="hljs-number">123</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">456</span>)<br>  &#125;<br>&#125;<br><br>mytest1()<br><span class="hljs-built_in">console</span>.log(a)    <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>那么，是先变量提升，还是先函数提升呢？</p><p>有不同意见的欢迎评论。</p><p><b style="color: red">从结果上看是函数优先，但从过程来看是变量优先</b></p><h3 id="预编译步骤"><a href="#预编译步骤" class="headerlink" title="预编译步骤"></a>预编译步骤</h3><p>这是怎么回事呢？</p><h4 id="全局预编译"><a href="#全局预编译" class="headerlink" title="全局预编译"></a>全局预编译</h4><p>首先先来看一下全局预编译的3个步骤：</p><ol><li>创建<code> GO对象(Global Object)</code></li><li>找变量声明，将变量作为<code>GO属性</code>(在浏览器中的话，实际上就是挂载到<code> window</code>对象上)，值为<code> undefined</code></li><li>找函数声明，作为<code> GO属性</code>值为函数体</li></ol><p>案例分析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>)<br><span class="hljs-built_in">console</span>.log(a)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">333</span><br><br><span class="hljs-built_in">console</span>.log(a)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">444</span>)<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(b)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">555</span>)<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(b)<br></code></pre></td></tr></table></figure><ol><li><p>创建<code> GO对象</code>，找变量声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">GO: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>找函数声明(会覆盖掉重名的)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">GO: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>)<br>    &#125;,<br>    <span class="hljs-attr">b</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">555</span>)<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>全局预编译过程结束，开始真正的编译过程(把提升的给去掉先)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>)<br><span class="hljs-built_in">console</span>.log(a)<br><br>a = <span class="hljs-number">333</span><br><br><span class="hljs-built_in">console</span>.log(a)<br><br><span class="hljs-built_in">console</span>.log(b)<br><br><span class="hljs-built_in">console</span>.log(b)<br></code></pre></td></tr></table></figure></li><li><p>结合<code> GO对象</code>的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>)<br><span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">// f a() &#123; console.log(222) &#125;</span><br><br>a = <span class="hljs-number">333</span><br><br><span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">// 333</span><br><br><span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">// f b() &#123; console.log(555) &#125;</span><br><br><span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">// f b() &#123; console.log(555) &#125;</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="局部-函数-预编译"><a href="#局部-函数-预编译" class="headerlink" title="局部(函数)预编译"></a>局部(函数)预编译</h4><blockquote><p><strong>GO对象是全局预编译，所以它优先于AO对象所创建和执行。</strong></p></blockquote><p>首先先来看一下局部预编译的4个步骤：</p><ol><li>创建<code> AO对象(Activation Object)</code></li><li>找形参和变量声明，将变量和形参作为<code> AO属性</code>，值为<code> undefined</code></li><li>实参和形参统一(将实参的值赋值给形参)</li><li>找函数声明，值赋予函数体</li></ol><p>案例分析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a)<br>  <span class="hljs-built_in">console</span>.log(b)<br>  <span class="hljs-built_in">console</span>.log(c)<br><br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">111</span><br>  <span class="hljs-built_in">console</span>.log(a)<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>)<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(a)<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">333</span>)<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(a)<br><br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">444</span><br>  <span class="hljs-built_in">console</span>.log(b)<br>    <br>  <span class="hljs-keyword">var</span> c = <span class="hljs-number">555</span><br>  <span class="hljs-built_in">console</span>.log(c)<br>&#125;<br><br>mytest(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br></code></pre></td></tr></table></figure><ol><li><p>创建<code> AO对象</code></p></li><li><p>找形参和变量声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">AO: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-literal">undefined</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-literal">undefined</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实参与形参统一</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">AO: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">123</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">456</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>找函数声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">AO: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">333</span>)<br>    &#125;,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">456</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>局部预编译过程结束，开始真正的编译过程(把提升的给去掉先)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a)<br>  <span class="hljs-built_in">console</span>.log(b)<br>  <span class="hljs-built_in">console</span>.log(c)<br><br>  a = <span class="hljs-number">111</span><br>  <span class="hljs-built_in">console</span>.log(a)<br><br>  <span class="hljs-built_in">console</span>.log(a)<br><br>  <span class="hljs-built_in">console</span>.log(a)<br><br>  b = <span class="hljs-number">444</span><br>  <span class="hljs-built_in">console</span>.log(b)<br>    <br>  c = <span class="hljs-number">555</span><br>  <span class="hljs-built_in">console</span>.log(c)<br>&#125;<br><br>mytest(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br></code></pre></td></tr></table></figure></li><li><p>结合<code> AO对象</code>的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytest</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">// f a() &#123; console.log(333) &#125;</span><br>  <span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">// 456</span><br>  <span class="hljs-built_in">console</span>.log(c)<span class="hljs-comment">// undefined</span><br><br>  a = <span class="hljs-number">111</span><br>  <span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">// 111</span><br><br>  <span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">/// 111</span><br><br>  <span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">// 111</span><br><br>  b = <span class="hljs-number">444</span><br>  <span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">// 444</span><br>    <br>  c = <span class="hljs-number">555</span><br>  <span class="hljs-built_in">console</span>.log(c)<span class="hljs-comment">// 456</span><br>&#125;<br><br>mytest(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br></code></pre></td></tr></table></figure></li></ol><p><b style="color: red">从结果上看是函数优先，但从过程来看是变量优先，因为变量提升后被之后的函数提升给覆盖掉了。</b></p><h2 id="回归正题"><a href="#回归正题" class="headerlink" title="回归正题"></a>回归正题</h2><p>准备好基础知识后，自然就是<strong>不忘初心，开始解决最开始的问题</strong></p><p>参考：<a href="https://stackoverflow.com/questions/58619924/function-declaration-in-block-moving-temporary-value-outside-of-block">Function declaration in block moving temporary value outside of block?</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(a)<br>  a = <span class="hljs-number">111</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123; &#125;<br>  a = <span class="hljs-number">222</span><br>  <span class="hljs-built_in">console</span>.log(a)<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(a)<br></code></pre></td></tr></table></figure><p>分析：</p><ol><li><p>会有两个变量声明<code> a</code>，一个在块内，一个在块外</p></li><li><p>函数声明被提升，并<strong>被绑定到内部的块变量上</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">var</span> a¹;<br> <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>²(<span class="hljs-params"></span>) </span>&#123;&#125; <br>   <span class="hljs-built_in">console</span>.log(a²)<br>   a² = <span class="hljs-number">111</span><br>   a² = <span class="hljs-number">222</span><br>   <span class="hljs-built_in">console</span>.log(a²)<br>&#125;<br><span class="hljs-built_in">console</span>.log(a¹);<br></code></pre></td></tr></table></figure></li><li><p>这么一看，这不是和局部变量提升差不多。但是，<b style="color: red">当到达原来的函数声明处，会把块变量赋值给外部变量</b></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">var</span> a¹;<br> <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>²(<span class="hljs-params"></span>) </span>&#123;&#125; <br>   <span class="hljs-built_in">console</span>.log(a²)<br>   a² = <span class="hljs-number">111</span><br>   a¹ = a²<span class="hljs-comment">// 当到达原来的函数声明处，会把块变量赋值给外部变量</span><br>   a² = <span class="hljs-number">222</span><br>   <span class="hljs-built_in">console</span>.log(a²)<br>&#125;<br><span class="hljs-built_in">console</span>.log(a¹);<br></code></pre></td></tr></table></figure></li><li><p>之后，块变量和外部变量不再有联系，即块变量变化不会导致外部变量的变化。</p></li><li><p>依次输出<code> f a() &#123;&#125;</code>、<code> 222</code>、<code> 111</code> </p></li></ol><p>为什么<b style="color: red">当到达原来的函数声明处，会把块变量赋值给外部变量</b>？</p><blockquote><p>the spec says so. I have no idea why. – <a href="https://stackoverflow.com/users/5260024/jonas-wilms">Jonas Wilms</a></p></blockquote><p><b style="color: red">不要用块级声明式函数</b></p><p><b style="color: red">不要用块级声明式函数</b></p><p><b style="color: red">不要用块级声明式函数</b></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>)<br>  &#125;<br><br>  <span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">// f b() &#123; console.log(111) &#125;</span><br>&#125;<br><br><br><span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">// f b() &#123; console.log(111) &#125;</span><br></code></pre></td></tr></table></figure><p>根据上面的分析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>²(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>)<br>  &#125;<br>    <br>  b¹ = b²<span class="hljs-comment">// 没有定义，直接赋值，变为全局变量</span><br><br>  <span class="hljs-built_in">console</span>.log(b²)<span class="hljs-comment">// f b() &#123; console.log(111) &#125;</span><br>&#125;<br><br><br><span class="hljs-built_in">console</span>.log(b¹)<span class="hljs-comment">// f b() &#123; console.log(111) &#125;</span><br></code></pre></td></tr></table></figure><p>我们把<code>if语句</code>的条件变为<code>false</code>后：</p><ul><li><code> if语句</code>的内容不再执行，合理</li><li>函数没有被提升到外面<ul><li>但是考虑到<code> if条件</code>为<code> false</code>的话，可能不会预编译内容</li><li>但是外边的<code> b</code>却不是报错<code> b is not defined</code>，而是输出<code> undefined</code></li></ul></li></ul><p>为什么？不知道，想不到原因，有人知道的话，评论告诉一下。(不会这样用，纯好奇为什么)</p><p>实际上，想要根据条件切换函数，可以用以下形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fn<br><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>)<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>)<br>  &#125;<br>&#125;<br><br>fn()<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一道问题引起的重学预编译&quot;&gt;&lt;a href=&quot;#一道问题引起的重学预编译&quot; class=&quot;headerlink&quot; title=&quot;一道问题引起的重学预编译&quot;&gt;&lt;/a&gt;一道问题引起的重学预编译&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言：变量提升与函数提升本来是我个</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.clzczh.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码之虚拟DOM和diff算法(二)    手写diff算法</title>
    <link href="https://www.clzczh.top/2022/04/04/vue-virtualDOM-diff-2/"/>
    <id>https://www.clzczh.top/2022/04/04/vue-virtualDOM-diff-2/</id>
    <published>2022-04-04T06:22:41.000Z</published>
    <updated>2022-04-23T05:01:44.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue源码之虚拟DOM和diff算法-二-手写diff算法"><a href="#Vue源码之虚拟DOM和diff算法-二-手写diff算法" class="headerlink" title="Vue源码之虚拟DOM和diff算法(二)    手写diff算法"></a>Vue源码之虚拟DOM和diff算法(二)    手写diff算法</h1><p>个人练习结果仓库(持续更新)：<a href="https://github.com/13535944743/Vue_Source_Code_Practise">Vue源码解析</a></p><h2 id="patch函数简要流程"><a href="#patch函数简要流程" class="headerlink" title="patch函数简要流程"></a>patch函数简要流程</h2><p><img src="https://s2.loli.net/2022/04/23/E5qZJSoy4CzYtwA.png" alt="image-20220318114622291"></p><br><h2 id="新旧节点不是同一个虚拟节点-新节点内容是-text"><a href="#新旧节点不是同一个虚拟节点-新节点内容是-text" class="headerlink" title="新旧节点不是同一个虚拟节点(新节点内容是 text)"></a>新旧节点不是同一个虚拟节点(新节点内容是<code> text</code>)</h2><p>不做过多解释了，代码中已经把每一步都解释了</p><p>src \ mysnabbdom \ patch.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> vnode <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./vnode.js&#x27;</span><br><span class="hljs-keyword">import</span> createElement <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./createElement.js&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">oldVnode, newVnode</span>) </span>&#123;<br>  <span class="hljs-comment">// 表示是真实DOM，真实DOM需要先转换成虚拟DOM后才进行下面的操作。因为真实DOM是没有sel这个属性的</span><br>  <span class="hljs-keyword">if</span> (oldVnode.sel === <span class="hljs-string">&#x27;&#x27;</span> || oldVnode.sel === <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-comment">// 转换成虚拟DOM</span><br>    oldVnode = vnode(oldVnode.tagName.toLowerCase(), &#123;&#125;, [], <span class="hljs-string">&#x27;&#x27;</span>, oldVnode)<br>  &#125;<br><br>  <span class="hljs-comment">// 判断oldVnode和newVnode是不是同一个节点</span><br>  <span class="hljs-keyword">if</span> (oldVnode.sel === newVnode.sel &amp;&amp; oldVnode.key === newVnode.key) &#123;<br>    <span class="hljs-comment">// 是同一个虚拟节点，需要进行精细化比对，最小化更新</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;需要精细化比对&#x27;</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 不是同一个虚拟节点，暴力删除旧的，插入新的</span><br><br>    <span class="hljs-keyword">const</span> newDomNode = createElement(newVnode)     <span class="hljs-comment">// 把新虚拟节点变成真实DOM</span><br><br>    <span class="hljs-keyword">const</span> pivot = oldVnode.elm<br><br>    <span class="hljs-comment">// 将新创建的孤儿节点上树</span><br>    pivot.parentNode.insertBefore(newDomNode, pivot)<br>    <span class="hljs-comment">// 删除旧的</span><br>    pivot.parentNode.removeChild(pivot)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>如果<code> oldVnode</code>和<code> newVnode</code>不是同一个虚拟节点，那么就直接暴力删除旧的，插入新的。</p><p>所以需要一个函数<code> createElement</code>，它的功能是将新虚拟节点创建为DOM节点并返回。</p><br><p>src \ mysnabbdom \  createElement.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 真正创建节点，将vnode创建为DOM</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">vnode</span>) </span>&#123;<br>  <span class="hljs-comment">// 创建一个DOM节点，此时还是孤儿节点</span><br>  <span class="hljs-keyword">const</span> domNode = <span class="hljs-built_in">document</span>.createElement(vnode.sel)<br><br>  <span class="hljs-keyword">if</span> (vnode.text !== <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; (vnode.children === <span class="hljs-literal">undefined</span> || vnode.children.length === <span class="hljs-number">0</span>)) &#123;<br>    <span class="hljs-comment">// 内部是文字</span><br>    domNode.innerText = vnode.text<br>    vnode.elm = domNode<br>  &#125;<br><br>  <span class="hljs-comment">// 返回真实DOM对象</span><br>  <span class="hljs-keyword">return</span> vnode.elm<br>&#125;<br></code></pre></td></tr></table></figure><br><p>测试</p><p>src \ index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> h <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mysnabbdom/h.js&#x27;</span><br><span class="hljs-keyword">import</span> patch <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mysnabbdom/patch.js&#x27;</span><br><br><span class="hljs-keyword">const</span> myVnode1 = h(<span class="hljs-string">&#x27;h2&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;文字&#x27;</span>)<br><br><span class="hljs-comment">// container只是占位符，上树后会消失</span><br><span class="hljs-keyword">const</span> container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>)<br><br>patch(container, myVnode1)     <span class="hljs-comment">// 上树</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/04/hs9Knb345AB6MES.png" alt="image-20220318145123182"></p><br><p><strong>新旧虚拟节点不是同一个节点，都能实现上树(不只是第一次)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> h <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mysnabbdom/h.js&#x27;</span><br><span class="hljs-keyword">import</span> patch <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mysnabbdom/patch.js&#x27;</span><br><br><br><span class="hljs-keyword">const</span> myVnode1 = h(<span class="hljs-string">&#x27;h2&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;hello&#x27;</span>)<br><br><span class="hljs-comment">// container只是占位符，上树后会消失</span><br><span class="hljs-keyword">const</span> container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>)<br><br>patch(container, myVnode1)     <span class="hljs-comment">// 上树</span><br><br><span class="hljs-keyword">const</span> myVnode2 = h(<span class="hljs-string">&#x27;h3&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;hi&#x27;</span>)<br><br>patch(myVnode1, myVnode2)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/04/tgNlzY5FqxAS8Up.png" alt="image-20220320152958956"></p><br><h2 id="新旧节点不是同一个虚拟节点-新节点内容是子节点"><a href="#新旧节点不是同一个虚拟节点-新节点内容是子节点" class="headerlink" title="新旧节点不是同一个虚拟节点(新节点内容是子节点)"></a>新旧节点不是同一个虚拟节点(新节点内容是子节点)</h2><p>src \ mysnabbdom \  createElement.js(部分)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(vnode.children) &amp;&amp; vnode.children.length &gt;= <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-comment">// 内部是子节点,需要递归创建子节点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; vnode.children.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> childDomNode = createElement(vnode.children[i])   <span class="hljs-comment">// 递归创建子节点</span><br><br>    <span class="hljs-comment">// 创建的子节点需要添加到DOM节点里</span><br>    domNode.appendChild(childDomNode)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>测试</p><p>src \ index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> h <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mysnabbdom/h.js&#x27;</span><br><span class="hljs-keyword">import</span> patch <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mysnabbdom/patch.js&#x27;</span><br><br><br><span class="hljs-keyword">const</span> myVnode1 = h(<span class="hljs-string">&#x27;ul&#x27;</span>, &#123;&#125;, h(<span class="hljs-string">&#x27;li&#x27;</span>, &#123;&#125;, [<br>  h(<span class="hljs-string">&#x27;li&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;赤&#x27;</span>),<br>  h(<span class="hljs-string">&#x27;li&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;蓝&#x27;</span>),<br>  h(<span class="hljs-string">&#x27;li&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;紫&#x27;</span>),<br>  h(<span class="hljs-string">&#x27;li&#x27;</span>, &#123;&#125;, [<br>    h(<span class="hljs-string">&#x27;div&#x27;</span>, &#123;&#125;, [<br>      h(<span class="hljs-string">&#x27;ol&#x27;</span>, &#123;&#125;, [<br>        h(<span class="hljs-string">&#x27;li&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;白&#x27;</span>),<br>        h(<span class="hljs-string">&#x27;li&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;黑&#x27;</span>)<br>      ])<br>    ])<br>  ]),<br>]<br>))<br><br><span class="hljs-comment">// container只是占位符，上树后会消失</span><br><span class="hljs-keyword">const</span> container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>)<br><br>patch(container, myVnode1)     <span class="hljs-comment">// 上树</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/04/bDWmUx3TZsJR84c.png" alt="image-20220318160421847"></p><br><h2 id="patch函数精细化比对流程"><a href="#patch函数精细化比对流程" class="headerlink" title="patch函数精细化比对流程"></a>patch函数精细化比对流程</h2><p><img src="https://s2.loli.net/2022/04/04/3gsT4NoezujpiaD.png" alt="image-20220404140651575"></p><br><h2 id="patch函数"><a href="#patch函数" class="headerlink" title="patch函数"></a>patch函数</h2><p><strong>实现简单部分的精细化比对，即不包括流程图中星星部分</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判断oldVnode和newVnode是不是同一个节点</span><br><span class="hljs-keyword">if</span> (oldVnode.sel === newVnode.sel &amp;&amp; oldVnode.key === newVnode.key) &#123;<br>  <span class="hljs-comment">// 是同一个虚拟节点，需要进行精细化比对，最小化更新</span><br>  patchVnode(oldVnode, newVnode)<br>  <span class="hljs-keyword">if</span> (oldVnode === newVnode) &#123;<br>    <span class="hljs-comment">// oldVnode和newVnode是内存上的同一对象，即完全相同，不做任何处理</span><br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (newVnode.text !== <span class="hljs-literal">undefined</span> &amp;&amp; (newVnode.children === <span class="hljs-literal">undefined</span> || newVnode.children.length === <span class="hljs-number">0</span>)) &#123;<br>    <span class="hljs-comment">// newVnode的内容是text，而不是子节点</span><br>    <span class="hljs-keyword">if</span> (newVnode.text === oldVnode.text) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    oldVnode.elm.innerText = newVnode.text<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// newVnode的内容是子节点</span><br>    <span class="hljs-keyword">if</span> (oldVnode.children !== <span class="hljs-literal">undefined</span> &amp;&amp; oldVnode.children.length &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// newVnode的内容是子节点，oldVnode的内容也是子节点</span><br><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;最复杂的情况&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// newVnode的内容是子节点，而oldVnode的内容是text：需要清空oldVnode，然后再把newVnode的children添加DOM上</span><br>      oldVnode.elm.innerText = <span class="hljs-string">&#x27;&#x27;</span><br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newVnode.children.length; i++) &#123;<br>        <span class="hljs-keyword">let</span> domNode = createElement(newVnode.children[i])<br>        oldVnode.elm.append(domNode)<br>      &#125;<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>测试</strong></p><p>oldVnode和newVnode是内存中同一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myVnode1 = h(<span class="hljs-string">&#x27;h2&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;hello&#x27;</span>)<br><br><span class="hljs-comment">// container只是占位符，上树后会消失</span><br><span class="hljs-keyword">const</span> container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>)<br><br>patch(container, myVnode1)     <span class="hljs-comment">// 上树</span><br><br><span class="hljs-keyword">const</span> myVnode2 = myVnode1<br><br>patch(myVnode1, myVnode2)<br></code></pre></td></tr></table></figure><br><p><code> newVnode</code>的内容是<code> text</code>，<code> oldVnode</code>的内容是子节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myVnode1 = h(<span class="hljs-string">&#x27;h2&#x27;</span>, &#123;&#125;, h(<span class="hljs-string">&#x27;p&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;hello&#x27;</span>))<br><br><span class="hljs-comment">// container只是占位符，上树后会消失</span><br><span class="hljs-keyword">const</span> container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>)<br><br>patch(container, myVnode1)     <span class="hljs-comment">// 上树</span><br><br><span class="hljs-keyword">const</span> myVnode2 = h(<span class="hljs-string">&#x27;h2&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;hi&#x27;</span>)<br><br>patch(myVnode1, myVnode2)<br></code></pre></td></tr></table></figure><br><p><code>newVnode</code>和<code> oldVnode</code>的内容都是<code> text</code>(只写不同的，相同的自测)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myVnode1 = h(<span class="hljs-string">&#x27;h2&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;hello&#x27;</span>)<br><br><span class="hljs-comment">// container只是占位符，上树后会消失</span><br><span class="hljs-keyword">const</span> container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>)<br><br>patch(container, myVnode1)     <span class="hljs-comment">// 上树</span><br><br><span class="hljs-keyword">const</span> myVnode2 = h(<span class="hljs-string">&#x27;h2&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;hi&#x27;</span>)<br><br>patch(myVnode1, myVnode2)<br></code></pre></td></tr></table></figure><br><p><code> newVnode</code>的内容是子节点，<code> oldVnode</code>的内容是<code> text</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myVnode1 = h(<span class="hljs-string">&#x27;section&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;hello&#x27;</span>)<br><br><span class="hljs-comment">// container只是占位符，上树后会消失</span><br><span class="hljs-keyword">const</span> container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>)<br><br>patch(container, myVnode1)     <span class="hljs-comment">// 上树</span><br><br><span class="hljs-keyword">const</span> myVnode2 = h(<span class="hljs-string">&#x27;section&#x27;</span>, &#123;&#125;, [<br>  h(<span class="hljs-string">&#x27;p&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;赤&#x27;</span>),<br>  h(<span class="hljs-string">&#x27;p&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;蓝&#x27;</span>),<br>  h(<span class="hljs-string">&#x27;p&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;紫&#x27;</span>)<br>])<br>patch(myVnode1, myVnode2)<br></code></pre></td></tr></table></figure><br><h2 id="diff的子节点更新策略"><a href="#diff的子节点更新策略" class="headerlink" title="diff的子节点更新策略"></a>diff的子节点更新策略</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li><p>将精细化比对，最小化更新部分代码封装成函数<code> patchVnode</code></p></li><li><p>修改<code> vnode.js</code>文件，将data中的<code>key</code>取出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sel, data, children, text, elm</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    sel,<br>    data,<br>    children,<br>    text,<br>    elm,<br>    <span class="hljs-attr">key</span>: data.key<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><br><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://s2.loli.net/2022/04/04/tQLGAk5iPlr1Ocj.png" alt="image-20220321093329463"></p><br><p>如上图所示，一共有四个指针，其中，旧前、旧后指向旧子节点的首尾，新前、新后指向新子节点的首尾。</p><p><strong>有四种命中查找：命中一种就不会再进行命中判断了。没有命中的话，则按箭头方向换一种命中查找方式</strong></p><p><img src="https://s2.loli.net/2022/04/04/pyjT7KADSEGwCb8.png" alt="image-20220321093851898"></p><p><strong>规则：</strong></p><ul><li><code>前指针</code>只能向下移动，<code>后指针</code>只能向上移动</li><li>当<code>前指针</code>在<code>后指针</code>下面时，循环完毕、(不包括在相同位置的情况)</li></ul><br><h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><p><b style="color: red">为了简便，直接把子节点用一个字母来表示</b></p><p>简单版本：</p><p><img src="https://s2.loli.net/2022/03/21/VvKgDAT4fwesByR.png" alt="image-20220321115109525"></p><blockquote><p><strong>如果旧节点先循环完毕，则此时新前指针、新后指针范围内的节点是新增节点</strong>(包括新前指针、新后指针指向的节点)</p></blockquote><br><p>复杂版本：</p><p><img src="https://s2.loli.net/2022/03/21/s1Vzk8ptXr2wRUN.png" alt="image-20220321150325730"></p><br><blockquote><p><strong>如果四种方式的查找都无法命中，则直接在旧子节点中寻找相同key的元素，不存在的话，新增并将该元素追加到<code>旧前指针</code>之前，<code>新前指针</code>下移</strong></p></blockquote><br><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><img src="https://s2.loli.net/2022/03/21/OyIpN57q8h2QYLJ.png" alt="image-20220321150243560"></p><br><h4 id="位置变换"><a href="#位置变换" class="headerlink" title="位置变换"></a>位置变换</h4><p><img src="https://s2.loli.net/2022/03/21/alzrCRy84DJLpSZ.png" alt="image-20220321155833724"></p><br><h4 id="增-删-位置变化"><a href="#增-删-位置变化" class="headerlink" title="增 + 删 + 位置变化"></a>增 + 删 + 位置变化</h4><p><img src="https://s2.loli.net/2022/03/21/fTLxJsXcowZriDu.png" alt="image-20220321162253189"></p><br><h4 id="key一样，节点内容却不同的情况"><a href="#key一样，节点内容却不同的情况" class="headerlink" title="key一样，节点内容却不同的情况"></a>key一样，节点内容却不同的情况</h4><p><a href="https://zhuanlan.zhihu.com/p/408728265">详解Vue的Diff算法(例6)</a></p><br><h3 id="原理总结"><a href="#原理总结" class="headerlink" title="原理总结"></a>原理总结</h3><ol><li><strong>新前旧前</strong>：<ul><li>命中，<code>新前指针</code>、<code>旧前指针</code>下移，回到1，继续看有没有命中</li><li>未命中，继续向下尝试命中</li></ul></li><li><strong>新后旧后</strong>：<ul><li>命中，<code>新后指针</code>、<code>旧后指针</code>上移，回到1，继续看有没有命中</li><li>未命中，继续向下尝试命中</li></ul></li><li><strong>新后旧前</strong>：<ul><li>命中，移动<code>旧前指针</code>指向的节点到<code>旧后指针</code>的后面，并将原位置设置为<code> undefined</code>，<code>旧前指针</code>下移，<code>新后指针</code>上移</li><li>未命中，继续向下尝试命中</li></ul></li><li><strong>新前旧后</strong>：<ul><li>命中，移动<code>旧后指针</code>指向的节点到<code>旧前指针</code>的前面，并将原位置设置为<code> undefined</code>，<code>旧后指针</code>上移，<code>新前指针</code>下移</li><li>未命中<ul><li>在旧节点中寻找相同<code>key</code>的节点<ul><li>存在<ul><li>在旧节点中找到的和<code>新前指针</code>指向的节点是同一个节点的话，将该节点追加到<code> 旧前</code>之前，并将原位置设置为<code> undefined</code>，<code> 新前指针</code>下移一位</li><li>在旧节点中找到的和<code>新前指针</code>指向的节点不是同一个节点的话，新增<code> 新前指针</code>指向的节点，将该节点追加到<code> 旧前指针</code>之前，<code> 新前指针</code>下移一位</li></ul></li><li>不存在<ul><li>新增并将该节点追加到<code> 旧前指针</code>之前，<code> 新前指针</code>下移一位</li></ul></li></ul></li></ul></li></ul></li><li>循环结束<ul><li>新节点先循环完毕：删除<code>旧前指针</code>、<code>旧后指针</code>之间的节点，包括<code> 旧前</code>、<code> 旧后</code>指向的节点</li><li>旧节点先循环完毕：新增<code>新前指针</code>、<code>新后指针</code>之间的节点到<code> 旧前指针</code>前，包括<code> 新前</code>、<code> 新后</code>指向的节点</li></ul></li></ol><br><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>src \ patchVnode.js(最复杂的情况，单独抽出来，在updateChildren中操作)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (oldVnode.children !== <span class="hljs-literal">undefined</span> &amp;&amp; oldVnode.children.length &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-comment">// newVnode的内容是子节点，oldVnode的内容也是子节点</span><br>  updateChildren(oldVnode.elm, oldVnode.children, newVnode.children)<br>&#125;<br></code></pre></td></tr></table></figure><br><p>src \ updateChildren.js</p><p>没什么难度，看原理总结慢慢写就行了(<strong>谨慎点</strong>)</p><p>阉割版本，只需要<code> sel</code>和<code> key</code>相同就认为是同一个虚拟节点。(即不需要判断内容是否相同)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 精细化比对，最小化更新的，其中新旧节点的内容都是节点的情况</span><br><br><span class="hljs-keyword">import</span> createElement <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./createElement.js&quot;</span><br><span class="hljs-keyword">import</span> patchVnode <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./patchVnode.js&quot;</span><br><br><span class="hljs-comment">// parentElm：oldVnode对应的真实DOM，用于更新DOM</span><br><span class="hljs-comment">// oldCh：旧节点的子节点</span><br><span class="hljs-comment">// newCh：新节点的子节点</span><br><br><span class="hljs-comment">// 判断是不是同一个虚拟节点</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkSamVnode</span>(<span class="hljs-params">v1, v2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> v1.sel === v2.sel &amp;&amp; v1.key === v2.key<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateChildren</span>(<span class="hljs-params">parentElm, oldCh, newCh</span>) </span>&#123;<br>  <span class="hljs-comment">// 旧前指针</span><br>  <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 旧后指针</span><br>  <span class="hljs-keyword">let</span> oldEndIdx = oldCh.length - <span class="hljs-number">1</span><br>  <span class="hljs-comment">// 旧前节点</span><br>  <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>]<br>  <span class="hljs-comment">// 旧后节点</span><br>  <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx]<br><br>  <span class="hljs-comment">// 新前指针</span><br>  <span class="hljs-keyword">let</span> newStartIdx = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 新后指针</span><br>  <span class="hljs-keyword">let</span> newEndIdx = newCh.length - <span class="hljs-number">1</span><br>  <span class="hljs-comment">// 新前节点</span><br>  <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>]<br>  <span class="hljs-comment">// 新后节点</span><br>  <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx]<br><br>  <span class="hljs-keyword">let</span> map = &#123;&#125;;<br><br>  <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp; newStartIdx &lt;= newEndIdx) &#123;<br>    <span class="hljs-keyword">if</span> (oldStartVnode === <span class="hljs-literal">undefined</span>) &#123;<br>      <span class="hljs-comment">// 跳过undefined</span><br>      oldStartVnode = oldCh[++oldStartIdx]<br>    &#125;<br>    <span class="hljs-keyword">if</span> (oldEndVnode === <span class="hljs-literal">undefined</span>) &#123;<br>      <span class="hljs-comment">// 跳过undefined</span><br>      oldEndVnode = oldCh[--oldEndIdx]<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (checkSamVnode(newStartVnode, oldStartVnode)) &#123;<br>      <span class="hljs-comment">// 新前旧前命中</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;新前旧前命中&#x27;</span>)<br><br>      patchVnode(oldStartVnode, newStartVnode)<br>      oldStartVnode = oldCh[++oldStartIdx]<br>      newStartVnode = newCh[++newStartIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (checkSamVnode(newEndVnode, oldEndVnode)) &#123;<br>      <span class="hljs-comment">// 新后旧后命中</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;新后旧后命中&#x27;</span>)<br><br>      <span class="hljs-comment">// 继续精细化比较两个节点</span><br>      patchVnode(oldEndVnode, newEndVnode)<br>      oldEndVnode = oldCh[--oldEndIdx]<br>      newEndVnode = newCh[--newEndIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (checkSamVnode(newEndVnode, oldStartVnode)) &#123;<br>      <span class="hljs-comment">// 新后旧前命中</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;新后旧前命中&#x27;</span>)<br><br>      <span class="hljs-comment">// 继续精细化比较两个节点</span><br>      patchVnode(oldStartVnode, newEndVnode)<br><br>      parentElm.insertBefore(oldStartVnode.elm, oldEndVnode.elm.nextSibiling)<br>      oldStartVnode = <span class="hljs-literal">undefined</span><br><br>      newEndVnode = newCh[--newEndIdx]<br>      oldStartVnode = oldCh[++oldStartIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (checkSamVnode(newStartVnode, oldEndVnode)) &#123;<br>      <span class="hljs-comment">// 新前旧后命中</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;新前旧后命中&#x27;</span>)<br><br>      <span class="hljs-comment">// 继续精细化比较两个节点</span><br>      patchVnode(oldEndVnode, newStartVnode)<br><br>      parentElm.insertBefore(oldEndVnode.elm, oldStartVnode.elm)<br>      oldEndVnode = <span class="hljs-literal">undefined</span><br><br>      newStartVnode = newCh[++newStartIdx]<br>      oldEndVnode = oldCh[--oldEndIdx]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 四种情况都没命中</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;<br>        <span class="hljs-keyword">const</span> item = oldCh[i]<br>        <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">undefined</span>) &#123;<br>          <span class="hljs-comment">// 跳过undefined</span><br>          <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">const</span> key = item.key<br>        map[key] = i<br>      &#125;<br><br>      <span class="hljs-comment">// 看一下map中有没有和新前指向的节点相同的</span><br>      <span class="hljs-keyword">const</span> indexOld = map[newStartVnode.key]<br>      <span class="hljs-keyword">if</span> (indexOld) &#123;<br>        <span class="hljs-comment">// 存在，则是移动</span><br>        <span class="hljs-keyword">const</span> elmToMove = oldCh[indexOld]<br>        <span class="hljs-comment">// 继续精细化比较</span><br>        patchVnode(elmToMove, newStartVnode)<br><br>        parentElm.insertBefore(elmToMove.elm, oldStartVnode.elm)<br>        oldCh[indexOld] = <span class="hljs-literal">undefined</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 不存在，需要新增节点</span><br>        <span class="hljs-keyword">const</span> newDomNode = createElement(newStartVnode)<br>        parentElm.insertBefore(newDomNode, oldStartVnode.elm)<br>      &#125;<br><br>      newStartVnode = newCh[++newStartIdx]<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (newStartIdx &lt;= newEndIdx) &#123;<br>    <span class="hljs-comment">// 旧节点先循环完毕，需要新增`新前指针`、` 新后指针`之间节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = newStartIdx; i &lt;= newEndIdx; i++) &#123;<br>      <span class="hljs-keyword">const</span> item = newCh[i]<br>      <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">const</span> newDomNode = createElement(item)<br><br>      <span class="hljs-keyword">if</span> (!oldStartVnode) &#123;<br>        <span class="hljs-comment">// 如果此时旧前指针指向的是undefined，则直接在最后插入</span><br>        parentElm.appendChild(newDomNode)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        parentElm.insertBefore(newDomNode, oldStartVnode.elm)<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldStartIdx &lt;= oldEndIdx) &#123;<br>    <span class="hljs-comment">// 新节点先循环完毕，需要删除`旧前指针`、` 旧后指针`之间节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;<br>      <span class="hljs-keyword">const</span> item = oldCh[i]<br>      <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      parentElm.removeChild(item.elm)<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><br><p>参考资料：</p><p><a href="https://zhuanlan.zhihu.com/p/408728265">详解Vue的Diff算法 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue源码之虚拟DOM和diff算法-二-手写diff算法&quot;&gt;&lt;a href=&quot;#Vue源码之虚拟DOM和diff算法-二-手写diff算法&quot; class=&quot;headerlink&quot; title=&quot;Vue源码之虚拟DOM和diff算法(二)    手写diff算法&quot;</summary>
      
    
    
    
    <category term="前端" scheme="https://www.clzczh.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Vue源码" scheme="https://www.clzczh.top/tags/Vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
